<<<<<<< HEAD

<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>async javascript - Jade's fantastic Blog</title>
  <meta name="author" content="zjhiphop">

  
  <meta name="description" content="异步的javascript Ways to do this: Browser Ways: use timeout/interval/requestAnimationFrame
web worker
promise mode
nesting function Node ways: 1. use &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zjhiphop.github.com/blog/2012/06/22/async-javascript">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Jade's fantastic Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Jade's fantastic Blog</a></h1>
  
    <h2>Make a difference.Where amazing happens!</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:zjhiphop.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About </a></li> 
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Async Javascript</h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-22T14:33:00+08:00" pubdate data-updated="true">Jun 22<span>nd</span>, 2012</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>异步的javascript</p>

<h2>Ways to do this:</h2>

<h3>Browser Ways:</h3>

<ol>
<li>use timeout/interval/requestAnimationFrame</li>
<li>web worker</li>
<li>promise mode</li>
<li>nesting function</li>
</ol>


<h3>Node ways: 1. use process.nexttick</h3>

<p><a href="http://altjs.org/">alternative js</a></p>

<h2>Rules</h2>

<ul>
<li>avoid more than two levels of function nesting</li>
<li>Exceptionslive strictly in the land ofsynchronicity. When you reach the event queue,the stack is reset. Everystack trace is an unbroken chain of blocking code</li>
</ul>


<h2>Exceptions in callbacks</h2>

<ol>
<li>在定时器中异常发生时只有发生出的堆栈信息</li>
<li>定时器中的异常在外部不能捕获到，可以使用window.onerror来捕获所有的异常<br/>
 setTimeout(function A() {
 setTimeout(function B(){

<pre><code> try{
     setTimeout(function C(){
         throw new Error('Something ter-rible has happened!');
     },0);   
 }catch(e){
     console.log(e);//定时器中的异常捕获不到
 }
</code></pre>

<p> },0);
 },0);</p></li>
</ol>


<p>Tools<br/>
1. ES6<br/>
   *  iterators and generators, yield x</p>

<pre><code>    function simpleGenerator(){  
      yield "first";  
      yield "second";  
      yield "third";  
      for (var i = 0; i &lt; 3; i++)  
        yield i;  
    }  

    var g = simpleGenerator();  
    print(g.next()); // prints "first"  
    print(g.next()); // prints "second"  
    print(g.next()); // prints "third"  
    print(g.next()); // prints 0  
    print(g.next()); // prints 1  
    print(g.next()); // prints 2  
    print(g.next()); // StopIteration is thrown  
</code></pre>

<ol>
<li><a href="http://taskjs.org/">task.js</a></li>
<li><a href="https://githubcom/maxtaco/tamejs">TameJS</a>

<ul>
<li><blockquote><p>This package is a source-to-source translator that outputs JavaScript. The input dialect looks a lot like JavaScript, but introduces the await primitive, which allows asynchronous callback style code to work more like straight-line threaded code. tamejs is written in JavaScript.
One of the core powers of the tamejs rewriting idea is that it&#8217;s fully compatible with existing vanilla-JS code (like node.js&#8217;s libraries). That is, existing node.js can call code that&#8217;s been output by the tamejs rewriter, and conversely, code output by the tamejs rewriter can call existing node.js code. Thus, tamejs is incrementally deployable &#8211;you can keep all of your old code and just write the new bits in tamejs! So try it out and let us know what you think.</p></blockquote></li>
</ul>
</li>
<li><a href="http://onilabs.com/stratifiedjs">StratifiedJS</a>

<ul>
<li>StratifiedJS extends the JavaScript language with a small number of constructs for concurrent programming. It allows you to express asynchronous control flow in a straightforward sequential style: <br/>
var news;<br/>
waitfor {<br/>
news = http.get(&#8220;http://news.bbc.co.uk&#8221;);<br/>
}<br/>
or {<br/>
hold(1000);<br/>
news = http.get(&#8220;http://news.cnn.com&#8221;);<br/>
}<br/>
or {<br/>
hold(1000*60);<br/>
throw &#8220;sorry, no news. timeout&#8221;;<br/>
}<br/>
show(news);</li>
</ul>
</li>
<li><a href="http://weepy.github.com/kaffeine/">Kaffeine</a>

<ul>
<li><blockquote><p>Kaffeine is a set of extensions to the Javascript syntax that attempt to make it nicer to use. It compiles directly into javascript that is very similar, readable and line for line equivalent to the input (you can beautify if you like).</p></blockquote></li>
</ul>
</li>
<li><a href="https://github.com/Sage/streamlinejs">Streamline.js</a></li>
<li><a href="https://github.com/laverdet/node-fibers">node-fibers</a> Fiber/coroutine support for v8 and node</li>
</ol>


<h2>Distribute Events</h2>

<blockquote><p>where a single incident can trigger
reactions throughout our application.</p></blockquote>

<ol>
<li>PubSub/EventEmitter</li>
<li>evented models

<ul>
<li>BackBone.js</li>
</ul>
</li>
<li>JQuery custom events

<ul>
<li>Callbacks</li>
<li>Namespaced Events</li>
</ul>
</li>
<li><a href="LucidJS">LucidJS</a>

<ul>
<li><blockquote><p>Lucid is an uber simple and easy to use event emitter library. Lucid allows you to create your own event system and even pipe in events from any number of DOM elements.</p></blockquote></li>
</ul>
</li>
</ol>


<blockquote><p>Some applications, particularly Node servers,<strong>use a single global PubSub object to connect otherwise isolated modules,enabling loose coupling and easy testing.</strong> Thegreat thing about PubSubis that when you’re not subscribing tothe events that are being published, it’s completely unobtrusive.</p></blockquote>

<h2>Promises and Deferreds</h2>

<blockquote><p>A Promiseis an object that represents a
task with two possible outcomes(successor
failure) and holds callbacks that fire when
one outcome or the other has occurred.
But the biggest advantage of using Promises
is that you can easily derive new Promises
from existing ones.You might ask two Promises representing parallel tasks to give you a
Promise that will inform you of their mutual
completion.Or you might ask a Promise representing the first task in aseries to give you
a Promise representing the final task in the
series.</p>

<pre><code>var promise = $.get('/mydata');
promise.done(onSuccess);
promise.fail(onFailure);
promise.fail(onAlways);
</code></pre></blockquote>

<h3><a href="http://wiki.commonjs.org/wiki/Promises/A">Promise/A spec</a></h3>

<ul>
<li><a href="https://github.com/kriskowal/q">KrisKowal’sQ.js</a>

<blockquote><p>Qis a fairly straightforward
implementation of the Promises/Aspec</p></blockquote></li>
<li><a href="https://github.com/coolaj86/futures">AJONeal’s Futures</a>

<blockquote><p>Futures is a broader toolkit, incorporating
manyofthe flow control features found in
libraries like Async.js</p></blockquote></li>
<li><a href="http://api.jquery.com/category/deferred-object/">jQuery 1.5’s Promises</a>

<ul>
<li>Every Deferred has a single Promise,and every Promise represents a Deferred.</li>
<li>You can trigger a Deferred directly.</li>
<li>jQuery 1.6+ provide one more source of Promises: ordinary jQuery objects.</li>
<li>Promises let us see concurrent tasks as booleans.

<ul>
<li>The most common use case for logically combining Promisesis finding out when a set of async tasks have finished.</li>
<li>$.when is logical AND</li>
<li>Implements NOT

<pre><code>function not(promise) {
  var result = new  $.Deferred(); 
  promise.done(result.reject);
  promise.fail(result.resolve); 
  return result; 
}
</code></pre></li>
<li>Implements OR

<pre><code>function or() {
    var promises=Array.prototype.slice.call(arguments); 
    var negatedPromises=promises.map(not);
    return not($.when.apply(this,negatedPromises));
}
</code></pre></li>
<li>Why?

<ol>
<li>When a Promise passed to or is resolved, its negation will be rejected,
as will the Promise returned by
$.when, and thus the Promise returned by or willbe immediately
resolved.</li>
<li>When all of the Promises passed to
and are rejected,their negations will
all be resolved, as will the Promise
returned by $.when, and thus the
Promise returned by or will be
rejected.</li>
</ol>
</li>
</ul>
</li>
<li>Deferred VS Promise

<ul>
<li>The most obvious differenceis that the then
method in faithful Promises/A implementations like Q.js returns a new Promise that
represents the eventual return value of the
success/failure handler. It’s a lot like
jQuery’s pipe method.</li>
<li>Another big difference, previously mentioned,is that jQuery uses the term “resolve” as he opposite of “fail,”whereasPromises/A      uses “fulfill.” Under Promises/A,a Promise  is said to be “resolved” when it’s either fulfilled or failed.</li>
<li>There are other,subtler differences as well.
For instance: In Promises/A, whether a
Promise returned then is fulfilled or rejected depends on whether the invoked callback
returns a value or throws an error.(Throwing errors from jQuery Promise callbacksis a
bad idea, as they’ll go uncaught.)</li>
</ul>
</li>
<li>When to use?

<ul>
<li>Ajax</li>
<li>animation</li>
<li>notification</li>
<li>progress</li>
<li>anthing need callback(s)</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2><a href="http://en.wikipedia.org/wiki/Flow_control">Flow control</a> with <a href="https://github.com/caolan/async">Aync.JS</a></h2>

<pre><code>Conditional Statements

    if statements
    if ... else ... statements 

Looping Statements

    while loops
    do ... while loops 

switch Statements

label Statements

with Statements 
</code></pre>

<h3>The async ordering problem</h3>

<ul>
<li>Example

<ul>
<li><p>Read all files content in a dir,we must make sure all contents is correct readed</p>

<p>  var fs = require(&#8216;fs&#8217;);<br/>
  var concatenation=&#8221;;<br/>
  fs.readdirSync(&#8216;recipes&#8217;)<br/>
  .filter(function(filename){</p>

<pre><code>  return fs.statSync(filename).isFile();  
</code></pre>

  })<br/>
  .forEach(function(filename){

<pre><code>  concatenation+=fs.readFileSync(filename,'utf8')  
</code></pre>

<p>  });<br/>
  console.log(concatenation);</p></li>
</ul>


<p>  Or</p>

<pre><code>  var fs = require('fs');
  var concatenation='';
  var dirContents=fs.readdirSync('recipes');
  function readFileAt(i){
      if(i===dirContents.length)return 
       console.log(concatenation);
      fs.stat(filename,function(err,stats){
          if(err)throw err;
      if(!stats.isFile())return readFileAt(i+1);
          fs.readFile(dirContents[i],'ut-f8',function(err,fileContents){
      if(err)throw err;
          concatenation+=fileContents;
          readFileAt(i+1);
      });
      });
  }
  readFileAt(0);
</code></pre></li>
<li>We need async series method

<ul>
<li>First,there’s a limit on the number of files    that Node(or any application process) can try to read simultaneously.</li>
<li>Second,if we ran the readFile callback in
parallel, we couldn’t just write concatenation += fileContents;</li>
<li>So we stick to async.forEachSeries for now  <br/>
<strong>var async= require(&#8216;async&#8217;); <br/>
var fs=require(&#8216;fs&#8217;); <br/>
var concatenation=&#8221;; <br/>
var dirContents=fs.readdirSync(&#8216;recipes&#8217;); <br/>
async.filter(                                           dirContents,isFilename,function(filenames){ <br/>
async.forEachSeries(   filenames,readAndConcat,onComplete); <br/>
}); <br/>
function onComplete(err){ <br/>
if(err)throw err; <br/>
  console.log(concatenation); <br/>
} <br/>
function isFilename(filename,callback){ <br/>
fs.stat(filename,function(err,stats){ <br/>
  callback(err?false:stats.isFile()); <br/>
}); <br/>
} <br/>
function readAndConcat(filename,callback){ <br/>
fs.readFile(filename,&#8217;utf8&#8217;,function(   err,fileContents){ <br/>
  if(err)return callback(err); <br/>
  concatenation+=fileContents; <br/>
  callback(); <br/>
}); <br/>
}</strong></li>
</ul>
</li>
<li>array utilities in async.js

<ul>
<li>reject/rejectSeries, the inverse of filter</li>
<li>map/mapSeries, for 1:1 transformations</li>
<li>reduce and reduceRight, for transforming a value at each step</li>
<li>detect/detectSeries, for finding a value matching a filter</li>
<li>sortBy, for generating a sorted copy</li>
<li>some for testing whetheratleast one value matches the given criterion</li>
<li>ever for testing whether all values match the given criterion</li>
</ul>
</li>
<li>Error-handling in Async.js

<ul>
<li>Async.js uses Node-style callbacks:The first
callback argumentis an error.</li>
</ul>
</li>
<li>Chaining async functions

<ul>
<li>async.series provides only the call-back to each task</li>
<li>async.waterfall provides the results from the previous task.<br/>
<strong>
var async= require(&#8216;async&#8217;);<br/>
var fs=require(&#8216;fs&#8217;);<br/>
var concatenation=&#8221;;<br/>
var fileTasks=fs.readdirSync(&#8216;recipes&#8217;)<br/>
.filter(function(filename){<br/>
 return fs.statSync(filename).isFile();<br/>
})<br/>
.map(function(filename,i){<br/>
return function(callback){<br/>
fs.readFile(file-name,&#8217;utf8&#8217;,callback);<br/>
};<br/>
});<br/>
async.series(fileTasks,func-tion(err,results){
if(err)throw err;<br/>
console.log(concatenation=results.join(&#8221;));<br/>
});<br/>
</strong></li>
<li>If any of our readFile attempts did cause an error,the series would terminate and our completion handler would be called with the error immediately.</li>
</ul>
</li>
<li>Parallelizing async functions

<ul>
<li>async.parallel it takes an array of func-tions of the form function(callback) {&#8230;}, plus an(optional) completion handler.</li>
</ul>
</li>
<li>All at once, or one at a time?

<ul>
<li>The task array is static. Once you’ve called async.series or async.parallel, you can’t add or remove tasks.</li>
<li>There’s also no way to ask, “How many tasks have been completed?”It’s   a black box,unless you dispatch updates from the tasks themselves.</li>
<li>You’re limited to either no concurrency or unlimited concurrency.</li>
</ul>
</li>
<li>Dynamic async queueing

<blockquote><p>async.queue’s interface is a bit more complex than that of async.series and async.parallel. It takes a function called the worker(rather than an array offunc-tions) and a concurrency value(the maximum number of simultaneous tasks the work-ercanprocess).Thenit returns a queue that
we can push arbitrary task data onto(along
with an optional callback).<br/>
  * example</p></blockquote>

  function worker(data,callback){<br/>
  console.log(data);<br/>
  callback()<br/>
  }<br/>
  var concurrency=4;<br/>
  var queue=async.queue(worker,concurrency);<br/>
  queue.push(1);<br/>
  queue.push(2);<br/>
  queue.push(3);

<ul>
<li>When it’s all done

<ul>
<li>drain

<blockquote><p>(Picture a tub full of tasks;when the last one has gone down the drain,the callack fires.)</p></blockquote></li>
<li>  queue.drain=function(){
  (console.log(&#8216;queue Completed in &#8216;+(new Date()-start)+&#8217;ms&#8217;);
  };</li>
</ul>
</li>
<li>use queue to search content<br/>
var async= require(&#8216;async&#8217;);
var fs=require(&#8216;fs&#8217;);
var concatenation=&#8221;;
var filenames=fs.readdirSync(&#8216;recipes&#8217;)
.filter(function(filename){
return fs.statSync(filename).isFile();
});
function worker(i,callback){
fs.readFile(filenames[i],&#8217;utf8&#8217;,function(err,result){
if(err)throwerr;
results[i]=result;
callback();
});
}
var concurrency=10;
var queue=async.queue(worker,concurrency);
var results=[];
for(vari=0;i&lt;file-names.length;i++){
queue.push(i);
}
queue.drain=function(){
console.log(concatenation=results.join(&#8221;));
};</li>
<li>Advanced queue callbacks

<ul>
<li>When  the  last  task  has  started  running,  the  queue  calls  empty.  (When the task finishes, it calls drain.)</li>
<li>When the concurrency limit is              reached, the queue calls saturated.</li>
<li>If  you provide a function as  the second  argument  in  a  push,  it’ll  be called  when  the  given  task (or  each task in the given array) is finished.</li>
</ul>
</li>
<li>Somting Qeuene can&#8217;t do

<ul>
<li>example

<ol>
<li>Read a configuration file</li>
<li>Connect to the database specified by
the configuration file</li>
<li>Connectto the cache specified by the
configuration file</li>
<li>Loadthe most used objects from the
database into the cache</li>
<li>Connect to an external API</li>
<li>Start responding to HTTP requests</li>
</ol>
</li>
<li>solution

<ul>
<li>Promise whens and thens</li>
<li>async.auto

<ul>
<li>example <br/>
  async.auto({

<pre><code>readConfigFile:readConfigFile,
connectToDB:
['readConfigFile',connectToDB],
connectToCache:['readConfigFile',connectToCache],
cacheObjects:
['connectToDB','connectToCache',cacheObjects],
connectToAPI: connectToAPI,
</code></pre>

<p>  acceptHTTPReqs:[&#8216;connectToDB&#8217;,&#8217;connectToCache&#8217;,&#8217;connectToAPI&#8217;,
  acceptHTTPReqs]
  });</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>alternative

<ul>
<li><p><a href="https://github.com/creationix/step">TimCaswell’s Step</a></p>

<blockquote><p>Stepis much lighter
  than Async.js,with an API consisting of a
  single function: Step. Step takes alist of
  functions, e.g.
  Step(task1, task2, task3);</p></blockquote></li>
<li><p><a href="https://github.com/coolaj86/futures">Futures</a></p></li>
<li><a href="https://github.com/nakamura-to/nue">nue</a></li>
<li><a href="https://github.com/isaacs/slide-flow-control">slide</a>

<h2>Multi-threading with Workers</h2></li>
<li><p>Web Workers</p>

<blockquote><p>WebWorkers are part of the living standard
  widely known as HTML5.To create one,you
  call the global Worker constructor with the
  URL of a script:</p></blockquote>

<pre><code>  var worker = new Worker('kimptoc.js');
  worker.addEventListener('error',function(){
  console.log('Ch
  failed to load.');
  });   
</code></pre>

<ul>
<li>Talking to Web Workers

<ul>
<li>self.postMessage</li>
</ul>
</li>
<li>Restrictions on Web Workers

<ul>
<li>Performing physics calculations for
games with CoffeePhysics.</li>
<li>Decoding video as it streams in with
the Broad way implementation of the
H.264 codec.</li>
<li>Encrypting communications with the
Stanford JavaScript Crypto Library</li>
<li>updatethe page.</li>
<li>can’tseethe global window object</li>
</ul>
</li>
<li>importScripts will(synchronously) load and run the given script(s)</li>
<li>browsers support WebWorkers

<ul>
<li>Chrome</li>
<li>FF</li>
<li>Safari</li>
</ul>
</li>
</ul>
</li>
<li><p>Node Workers with cluster</p>

<ul>
<li>Typically,cluster is used to spin up one
process per CPU core for optimal perform-ance(though whethe reach process will actu-allygetits own core is entirely upto the un-derlying OS):</li>
</ul>


<p>  var cluster = require(&#8216;cluster&#8217;);
  if(cluster.isMaster){
  // spin up workers
  var coreCount=require(&#8216;os&#8217;).cpus().length;
  for(vari=0;i&lt;coreCount;i++){
  cluster.fork();
  }
  // bind death event
  cluster.on(&#8216;death&#8217;,func-tion(worker){
  console.log(&#8216;Worker
  &#8216;+worker.pid+&#8217; has died&#8217;);
  });
  }else{
  // die immediately
  process.exit();
  }</p>

<ul>
<li>child_process.fork</li>
<li>Talking to Node Workers</li>
</ul>


<p>  var  cluster = require(&#8216;cluster&#8217;);
  if(cluster.isMaster){
  // spin up workers
  var coreCount=require(&#8216;os&#8217;).cpus().length;
  for(var i=0;i&lt;coreCount;i++){
  var worker=cluster.fork();
  worker.send(&#8216;Hello, Worker!&#8217;,2);
  worker.on(&#8216;message&#8217;,function(message){
  if(message._queryId)return;
  console.log(message);
  });
  }
  }else{
  process.send(&#8216;Hello, mainprocess!&#8217;);
  process.on(&#8216;message&#8217;,function(message){
  console.log(message);
  });
  }</p>

<ul>
<li>Restrictions on Node Workers

<blockquote><p>For the most part,cluster obeys the same
rules as WebWorkers:There’s a master,and
there are Workers;they communicate via
events with attached strings orserializable objects. However, while Workers are obviously second-class citizens in the  browser, Node’s Workers possess all the rights and privileges of the master except</p></blockquote>

<pre><code>1. The ability to shut down the application,
2. The ability to spawn more Workers,
and
3. The ability to communicate with each other.
</code></pre>

<ul>
<li><a href="https://github.com/fent/clusterhub">Clusterhub</a>

<blockquote><p>Clusterhubprovides a hub object to each
process that acts as an inter-process
EventEmitter and EventVat store</p></blockquote>

<ul>
<li><a href="https://github.com/hij1nx/EventVat">EventVat</a></li>
<li>  // master
  varhub=require(&#8216;clusterhub&#8217;);
  hub.set(&#8216;hitCount&#8217;,0);
  // Workers
  varhub=require(&#8216;clusterhub&#8217;);
  functiononRequest(){
  hub.in-cr(&#8216;hitCount&#8217;,func-tion(hitCount){
  // &#8230;
  });
  }</li>
</ul>
</li>
<li>Temporary threads

<ul>
<li>single block of synchronous code to be run in a  separate  thread</li>
<li>create  and manage a pool of  Web Workers</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>Async Problems and Solutions</h2>

<h3>Problem: Where’d this go?</h3>

<p>It’s  a  rite  of  passage  for  JavaScripters:  You pass  a  callback.  You  use  this in  that  callback,not  giving  the matter  much  thought.
You spend  the  next  several  hours  trying  to figure out why your code is broken and cursing the day you were born. Or, at least, you join  one of the thousands who’ve  posted  examples like this to Stack Overflow:</p>

<pre><code>    // each button has data indicating an "action" to take 
    $('button').click (function (){ 
    $(this).after ('&lt;a href="#" 
    id="confirm"&gt;Confirm&lt;/a&gt;'); 
    $('#confirm').click (function (){ 

    var action = $(this).data ('action'); 
         // why is action undefined???
    });
    });
</code></pre>

<p>jQuery bears some responsibility for the confusion.  Devs  who  are  unaware  of the call
and apply methods that can warp it to anything  a function’s caller desires expect  this to scope like an ordinary variable,  albeit one mysteriously  set  in  their  event  handlers  via dark magicks. But the problem also arises in ordinary setTimeouts:</p>

<pre><code>    var account = { 
    balance :500, 
    showBalance:function (){console.log (this.balance); } 
    }; 
    account.showBalance()
    setTimeout(account.showBalance, 0);// undefined 
</code></pre>

<p>account.showBalance() calls  the  method  in  the account context,  but when account.showBalance is  passed  to a  function, the original context is lost.</p>

<ul>
<li><p>Solution 1: Capture this</p>

<p>  The  most  common  solution to  this  problem
  is to simply store the value of this that you
  want  in  a  separate variable.  Traditionally,  a
  name like  selfis used, but I prefer a clearer
  identifier:</p>

<pre><code>  $('button').click (function () { 
    var button = this; 
    $(button).after ('&lt;a href="#" 
  id="confirm"&gt;Confirm&lt;/a&gt;')
  $('#confirm').click (function (){ 
   var action = $(button).data ('action'); 
      // works! 
     }); 
   }); 
</code></pre>

<p>  This works for our  setTimeout example as
  well: Just change showBalanceto</p>

<pre><code>  showBalance: function () { console.log (account.balance); } 
</code></pre></li>
<li><p>Solution 2:
Bind callbacks to this JavaScripters have long known that a function can be made impervious to the dark magicks of call and apply by wrapping them in another function.Utility libraries like Underscore.js include a bind method for just such a purpose:</p>

<pre><code>   $('button').click (function () { 
     $(this).after ('&lt;a href="#" 
   id="confirm"&gt;Confirm&lt;/a&gt;'); 
     $('#confirm').click (_ .bind (function (){ 

   var action = $(this).data ('action'); 
      // works! 
     },this)); 
   }); 
</code></pre>

<p>What we’ve done here is forced the inner callback to have the same value of this as the outer one. This is such a common pattern that CoffeeScript makes it as easy as declaring the bound function with  => instead of  ->.  In newer JS runtimes (cutting-edge browsers and Node),the bind method is part of the function prototype itself,  so we could write:</p>

<pre><code>  $('#confirm').click ((function () { 
     ... 
   }).bind (this)); 
</code></pre></li>
</ul>


<p>Binding is widely used but slightly controversial.  It’s generally less efficient than capturing this, and has a tendency to complicate stack traces. See Patrick Mueller’s blog post “<a href="http://pmuellr.blogspot.com/2010/06/bind-considered-harmful.html">bind() considered harmful.</a>”  Perhaps more importantly,  when some callbacks are bound  and  others  aren’t,  it  tends  to  exacerbate  confusion about what  this is at a particular line of code.</p>

<ul>
<li><p>Solution 3: Work around this This solution only applies to jQuery, as most libraries are content to allow this in callbacks to take its default value, the root object (window in browsers, global in Node).
jQuery is not, and some prominent JavaScript developers (including Jeremy Ashkenas, creator of CoffeeScript and Backbone.js) have called that a mistake. Although most jQuery coders use this to get the DOM element that an event was fired from, you can use the less ambiguous e.currentTarget instead (where e is the event object that jQuery passes as the first argument to the handler):</p>

<pre><code>   $('button').click (function (e) { 
   $(e.currentTarget).after ('&lt;a 
  href="#" 
  id="confirm"&gt;Confirm&lt;/a&gt;'); 
    $('#confirm').click (function (){ 

   var action = $(e.currentTarget).data ('action'); 
      // works! 
     }); 
   }); 
</code></pre>

<p>Of course, e is just as prone to overuse as this, so consider using a distinguishing identifier like buttonEvent instead.</p></li>
</ul>


<h3>Problem: Retrying async tasks</h3>

<p>Often, we’ll want to attempt an async task n times before declaring failure, particularly when the task involves connecting to a remote server.  The basics of this problem are obvious:
1.  We need to store the number of failed attempts
2.  When an attempt fails, we need to increment the number of failed attempts and check whether it exceeds the maximum This translates into a lot of boilerplate code that we don’t want to repeat every time we run into this scenario, e.g.</p>

<pre><code>    var callback, failedAttempts = 0, asyncTask (callback = function (err) { 
      if (err) { 
         failedAttempts++; 

     if (failedAttempts &gt;=maxAttempts) { 
           failCallback(err); 
         }else { 
          asyncTask (callback); 
         }; 
       }else { 

     successCallback (Array.prototype .slice.call (arguments, 1)); 
       }; 
     }); 
How can we make this simple? 
</code></pre>

<ul>
<li>Solution 1:
Callback-style Assuming that we’re using Node-style callbacks, we can translate our boilerplate above into a reusable utility function:

<pre><code>   function attemptAndRetry (asyncTask, maxAttempts, callback) { 
    asyncTask (function (err) { 
      if (err) { 
        if (maxAttempts &lt;= 1) { 
          callback (err); 
        }else { 

   attemptAndTry (asyncTask,maxAttempts 1,callback); 
        }; 
      }else { 

   callback (null,Array.prototype .slice.call (arguments 
    }; 
     }); 
   } 
</code></pre></li>
</ul>


<p>Notice that we’re using quasi-recursion here.
There’s no risk of exceeding the stack limit, as long as asyncTask’s callback runs from the event queue.</p>

<p>This is the most direct solution, but there are a couple of things I don’t like about it.  For one, calling the function is a tad awkward:</p>

<pre><code>    attemptAndRetry (function (callback) { 
      fs.readFile ('locked.txt', 'utf8',callback); 
     },3,function (err,result) { 
      // ... 
     }); 
</code></pre>

<p>Another problem is that we don’t get finegrained control over the process.         For instance, what if we want to log the error on each failed attempt?</p>

<ul>
<li>Solution 2:
PubSub-style As is so often the case in JavaScript, the best solution is an EventEmitter.  It allows us to expose an extremely versatile API from a simple function. To wit:

<pre><code>  var EventEmitter = require ('events').EventEmitter; 
  function attempt (asyncTask) { 
    var emitter = new EventEmitter (),results; 
    emitter.failedAttempts= 0; 
    function retry = function (){ 
  asyncTask (function (err) { 
        if (err) { 
          emitter.failedAttempts++; 

   emitter.emit ('failure',err,retry); 
        }else { 

   results = Array.prototype .slice.call (arguments, 1); 

   emitter.emit ('success',results); 
        } 
       }); 
     } 
    process .nextTick (retry); // ensure asynchronicity return emitter; 
   } 
</code></pre></li>
</ul>


<p>This may be a little more complicated than our earlier definition, but it makes things extremely easy for the caller:</p>

<pre><code>    var reading = attempt (function (callback) { 
      fs.readFile ('locked.txt', 'utf8',callback); 
     }); 
    reading.on ('failure',function (err,retry) { 
      console.error (err); 
      if (reading.failedAttempts&lt; 3)retry (); 
     }); 
    reading.on ('success',function (contents) { 

     // ... 
     }); 
</code></pre>

<p>Now we have cleanly exposed state and precise control over when we retry our function.
Plus, because we can attach multiple handlers for the same event, it’s easy to view the process state from multiple perspectives. We could, for example, map the task onto a Promise for easy monitoring:</p>

<pre><code>    var deferred = new $.Deferred (); 
    reading.on ('failure',function (err,retry) { 
      if (reading.failedAttempts &gt;= 3)deferred.reject (err); 
     }); 
    reading.on ('success',deferred.resolve) 
</code></pre>

<p> ###Problem: Testing async code In languages like Java and Ruby, test cases can just be lists of assertions. Unfortunately, that won’t cut it when testing async JavaScript code, because the test runner has no way of knowing when the test case is complete. It’s important to use a JavaScript testing framework that can handle async test cases and produce meaningful output despite the unpredictable order of assertions.</p>

<ul>
<li>Solution: Use Mocha The successor to Expresso, Mocha is a onesize-fits-all testing framework for both the browser and Node.  While async testing was something of a pain in older testing frameworks like QUnit (requiring async test cases to manually start and stop the runner), Mocha makes it  “just work.”  Here’s an example using Mocha’s T        -style interface (which I prefer for its simplicity over the default Bstyle interface):

<pre><code>  var assert = require ('assert'); 
  suite('gamification',function (){ 
    setup(gamify); 
    test ('gamify resets points',function (){ 
      assert.equal (points, 0); 
     }); 
    test ('player points are loaded on login',function (done) { 
      assert.equal (points, 0); 

   login (mock .username,mock .password,function (err,success) { 
        if (err)throw err; 
        assert.ok (success); 

   assert.equal (points,mock .points); 
     done (); 
       }); 
     }); 
   }); 
</code></pre></li>
</ul>


<p>Assume the assertions all pass.     When this code is run, via the command mocha  -u tdd test.js, the test runner will report the first test case’s success as soon as it returns, and will report the second test case’s success as soon as it calls done.         But wait—how did it know to wait for done to be called in the second case?</p>

<p>The magic here is in a JavaScript feature called arity.  The arity of a function is the number of declared arguments it takes. That number is exposed as the lengthproperty:</p>

<pre><code>(function () 
 { ... }).length;  // 0 (function (done) { ... }).length; // 
</code></pre>

<p>1 Using this to distinguish synchronous functions from async ones is a clever hack, though it comes with a caveat: If you accidentally declare a synchronous test case with an argument, e.g.</p>

<pre><code>    test ('bedard', function (done) { 
      assert.ok (true); 
     }); 
</code></pre>

<p>you’ll get the error output x 1 of 1 tests failed: 1)  bedard: Error: timeout of 2000ms exceeded Usually, declaring functions without unnecessary arguments is good style.  In Mocha, it’s a matter of life or death.</p>

<h3>Problem:</h3>

<p>Aggregating events With the rise of evented models, it’s become easy to oversaturate an application with events, slowing it to a crawl. For instance, in a game, we might represent each of thousands of characters in a level with a Backbone model and perform game logic in response to any changes in those models.  But when the player throws a grenade that blows up 100 monsters at once, we don’t want to perform the same logic 100 times.  How can we avoid this?</p>

<ul>
<li>Solution 1:
Silence the change events Backbone gives us a special flag that we can use to change models without them emitting a  &#8216;change&#8217;event:

<pre><code>  monsters.each (function (damage) { 
    this.set({life:this.get ('life')age}, {silent:true}); 
   }); 
</code></pre></li>
</ul>


<p>Used carefully, this is the most efficient solution to our problem. But it’ll only work if we have absolute knowledge about what’s supposed to happen when each model we’re silently modifying changes.</p>

<p>Silencing events is like a scalpel. With steady hands and precise planning, it can be an invaluable tool;  otherwise, it’s just going to make a mess.</p>

<ul>
<li>Solution 2:
Use a simple timeout Remember that even a 0ms delay will ensure that a function runs after all synchronous code.  We can use that to our advantage by having a checkGameState function runs just once after all of the individual monster models have been updated:

<pre><code>  var checkGameStateTimeout; 
   function checkGameState (){ 
     // if no monster allies remain, you lose var isTheGameLost= monsters .filter (function (){ 
      return this.get ('ally'); 
     }).length=== 0; 
     // and so on... 
  } 
  var monsters = new Backbone.Collection; 
  monsters .on ('change',function (){ 
    clearTimeout (checkGameStateTimeout); 
    checkGameStateTimeout = setTimeout( 
  GameState, 0); 
   }); 
</code></pre></li>
</ul>


<p>Now no matter how many monsters are changed simultaneously, checkGameState will fire just once in response.</p>

<ul>
<li>Solution 3:
Throttling/Debouncing We’ve looked at one solution that operates from the part of the app that updates the models and another that works from the models’ end.  But the most elegant approach is usually to act on the particular function that we want to prevent from being called too often.  In general terms, that means we want to limit checkGameState to running once every n milliseconds. There are two basic approaches to this:</li>
<li>Throttling, where additional calls to the function are ignored if its last run was less than n ms ago, and</li>
<li>Debouncing, where any call to the function is delayed until n ms have elapsed since the last call Usually, you want throttling, because debouncing adds some latency to every function call.    Plus, debouncing means that a function will never be called if it’s called too often! (Sometimes debouncing is implemented with a maximum delay to avoid this.)
However, debouncing is preferable in scenarios where you want to wait until an input source is idle, such as rendering a preview or running a validation only after the user has momentarily stopped typing.</li>
</ul>


<p>Both throttling and debouncing are easy to implement by creating a meta-function that returns a wrapped version of the original function.Here are two simple implementations:</p>

<pre><code>    function throttle (func, minDelay) { 
      var lastHitDate = 0; 
      return function (){ 
        var now = new Date (); 

     if (now lastHitDate &gt;=minDelay) { 
          lastHitDate = now; 

     return func.apply (this,arguments); 
        }; 
    }; 
     } 

    function debounce (func, delay) { 
      var timeout; 
      return function (){ 
        var args = arguments; 
        clearTimeout (timeout); 
        timeout = setTimeout(function (){ 
          func.apply (this,args); 
         },delay); 
       }; 
     } 

(If you’re using Underscore.js—and you should!—you can just use _.throttle and _.debounce.) 
</code></pre>

<p>With these utility functions, we can either overwrite checkGameState entirely or just use the wrapped version from our change events.  For our purposes, debounce with a delay of 0 is most appropriate, since throttle with a short delay would allow checkGameState to run more within a block of synchronous code. debouncewith a delay of 0 is effectively equivalent to the setTimeoutwe used in solution 2:</p>

<pre><code>    var debouncedCheckGameState = debounce (checkGameState, 0); 
    monsters .on ('change',function (){ 
      debouncedCheckGameState (); 
     }); 
</code></pre>

<p>Note that it’s important to use the same throttled/debounced instance of a function from every source that we want to limit calls from. Calling (debounce (checkGameState, 0))();
would just be an overly complicated way of calling setTimeout(checkGameState, 0);</p>

<p>because calling debounce(checkGameState, 0) again would just create a separate timeout.</p>

<h3>Problem:</h3>

<p>Handling requests Quick question:
You’re a web server. You receive a request. What do you do?</p>

<p>Most likely, lots of unrelated things. At a minimum, you look at the requested route and map it to a file that you send in response. But you also probably log the request, check whether the requester is properly authenticated, and fetch some data. Maybe you cache the response in memory, too. Many of these pieces of functionality will be the same for some or all routes. How do you avoid duplication?</p>

<ul>
<li>Solution:
The middleware pattern In the Node.js Connect framework, each middleware function takes a request object (req), a response object (res), and a next callback. Every time a new request comes in, it’s passed to the first middleware. The middleware has three (good) options:</li>
<li>Handle the request itself by sending a response and returning without calling next.</li>
<li>Call nextwith no arguments.</li>
<li><p>Call nextwith an error argument. The next callback Connect generates either passes the request on to the next middleware on the stack, or to an error handler. And that’s basically all Connect does. This simple pattern (the core implementation is less than 200 lines) has proven so successful that just about every Node server framework has been built on top of Connect, most notably Express.js. Consider using the middleware pattern in other contexts where an action needs to be handled in several discrete steps. The only difference between a middleware stack and an ordinary callback stack (like we saw in Chapter 2) is that each function on the stack receives a next function that allows it to declare that it’s finished, making an async series of actions possible. Here’s a minimal implementation for comparison’s sake:</p>

<pre><code>// callback stack function trigger (){ 
  handlers.forEach(function (handler) { 
    handler (); 
   }); 
 } 
// middleware stack function trigger (){ 
  invoke (0); 
 } 
function invoke (idx) { 
  if (handlers.length&lt;= idx) { 
    return; 
   }else { 
    handlers [idx](function (err) { 
      if (err)throw err; 

 if (handlers.length &gt; idx + 1)invoke (idx + 1); 
   }; 
} 
</code></pre></li>
</ul>


<p>Perceptive readers may be reminded of async.series from Chapter 4. Connecting functions this way is an extremely common pattern. Feel free to reinvent the wheel, but be aware that the wheel is already available under the MIT License.</p>

<h3>Problem:Ajax spaghetti</h3>

<p>Consider this an integrative exercise. How do we turn highly nested code like this into something clearer, better-organized, less repetitive, and easier to modify if we decide to change our application’s behavior?</p>

<pre><code>    $(function () { 
      $('#menu').on ('click', 'a',function clickHandler (){ 
        // we put a spinner on the selected menu item var $clickedLink= $(this).spin(); 
        // we disable the menu until our Ajax call returns 
        $('#menu').off ('click', 'li &gt; 
    a'); 

     $.get ('/content/'+ $clickedLink. success:function successHandler(response) { 
            $clickedLink.unspin (); 
            $('#menu').on ('click', 'li &gt; 
    a',clickHandler); 
            // we fade the content out... 

     $('#content').fadeOut(function (){ 
              // ...then we fade it in with the Ajax markup 

     $('#content').html (response).fadeIn(); 
            }); 
          }, error:function (){ 
            // we make one retry in case the error is just a fluke 
    $.get ('/content/' + $clickedLink.index (),{ 
              success:successHandler, error:function (){ 
                $clickedLink.unspin (); 
                $('#menu').on ('click', 'li &gt; 
    a',clickHandler); 
               modal ('Error retrieving content from the server.'); 
              } 
            }); 
          } 
        }); 
        return false; // prevent default click behavior 
      }); 
    }); 
</code></pre>

<ul>
<li>Solution:
Distribute, distribute, distribute The big problem with the code above is that it’s way too centralized. Everything that happens in response to a menu click goes in the click handler, and everything that happens in response to the Ajax request goes in the Ajax response handler. We need to spread things out in a way that makes sense. There are plenty of ways we could do that here—using custom jQuery events, for example—but the approach I’d recommend is using an evented model to represent the menu. The model will encapsulate the state that we need to capture from the various async events, and the abstraction will make it easy for us to change our event flow in the future. Let’s start by asking, “What state do we need to store?” I can think of three things:</li>
<li>Whether our menu is in its  “ready,”
clickable state, or in the     “unready”<br/>
state with a spinner over the active link.</li>
<li>Which link is currently active (in the process of having associated content loaded), if any.</li>
<li>How many attempts we’ve made so far to request content from the server for the active link. The first two sound like they should be associated with the menu. So that gives us our menu model:

<pre><code> window.menu = new Backbone.Model ({ 
   ready:false, activeLinkIndex:-1 
  }); 
</code></pre>

<p>Why does our menu start out with ready:
false? Because the menu element may not exist yet in the document. We want readyto correspond to the click handler being attached. We also want to ensure that there is no active link when the menu becomes ready:</p>

<pre><code>  menu .on ('change:ready', function (ready) { 
  if (ready) { 
  $('#menu').on ('click', 'li &gt; 
  a',menu .clickHandler); 
  menu .set('activeLinkIndex',-1); 
  }else { 
  $('#menu').off ('click', 'li &gt; 
  a'); 
  } 
  }); 
</code></pre></li>
</ul>


<p>Notice the reference to menu.clickHandler. For convenient namespacing, we’ll go ahead and attach all of our menu-related event handlers to the menu model:</p>

<pre><code>    menu .clickHandler = function () { 
      menu .set({ready:false,activeLinkIndex:$(this).index ()}); 
      return false; 
     } 
</code></pre>

<p>Declaring the menu ready is the only thing that has to wait for the DOM. So our jQuery callback, which originally wrapped around everything, is just a one-liner:</p>

<pre><code>    $(function () { menu .set({ready: 
    true}); 
</code></pre>

<p>(Note that it’s important for this line to come after menu.clickHandler is defined, because the callback will run synchronously if the document is already ready.)</p>

<p>The click handler modifies the menu’s activeLinkIndex, so let’s respond to that by fetching the appropriate content and adding the Ajax spinner to the correct menu item:</p>

<pre><code>    menu .on ('change:activeLinkIndex', function (activeLinkIndex) { 
      $('#menu').children ().unspin (); 
         .eq (activeLinkIndex).spin(); 
      menu .fetchSelectedContent(); 
     }); 
</code></pre>

<p>If activeLinkIndex is changed to  -1 (indicating that no link is active), the eq(activeLinkIndex) selector will match no elements, so no Ajax spinner will appear. And the first line of our fetchSelectedContentwill simply return:</p>

<pre><code>    menu .fetchSelectedContent = function () { 
      if (menu .get ('activeLinkIndex')=== -1)return; 
      $.ajax ({ 

     url: 
    '/content/'+menu .get ('activeLinkIndex'), tryCount:0 
       }) 
       .done ($('#content').fadeHtml) 
       .done (function (){menu .set({ready:true}); }) 
       .failure(function (){ 
        this.tryCount++; 
        if (this.tryCount &gt;= 2) { 
          modal ('Error retrieving content from the server.'); 
    }else { 
          $.ajax (this); 
         }; 
       });); 
     } 
</code></pre>

<p>This is our most complex function, but every line serves a clear purpose. When the Ajax call succeeds: <br/>
1. The content element’s fadeHtml method is called with the data retrieved from the server. fadeHtml is a simple plugin that we’ll define shortly.<br/>
2. The menu is restored to its ready state. Recall that this will also reset activeLinkIndexto 1. When the Ajax call fails:<br/>
1. this in a jQuery Ajax callback points to the jqXHR object that, among other things, stores all of the settings passed in to  $.ajax. We use that to store our tryCount.<br/>
2. Because this also contains our url property, we can simply write $.ajax(this) to reattempt the Ajax call. This technique was popularized by a blog post entitled  “Defensive Ajax and Ajax retries in jQuery.”</p>

<p>If we felt like the fetchSelectedContent method was too large, we could move the failure handler out of it. That’s the great thing about evented code:
As long as state is stored rationally, you have unlimited flexibility. Now the only gap left to fill in is to define fadeHtml:</p>

<pre><code>     $.fn.fadeHtml = function (markup) { 
      return this.fadeOut(function (){ 
        $(this).html (markup).fadeIn(); 
       }); 
     }; 
</code></pre>

<p>And that’s it! We have a little more code than we started with, but it’s many times easier to work with.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">zjhiphop</span></span>

      








  


<time datetime="2012-06-22T14:33:00+08:00" pubdate data-updated="true">Jun 22<span>nd</span>, 2012</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/thinking-in-js/'>thinking in JS</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://zjhiphop.github.com/blog/2012/06/22/async-javascript/" data-via="" data-counturl="http://zjhiphop.github.com/blog/2012/06/22/async-javascript/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2012/06/07/10-small-habits-of-less-stressed-people/" title="Previous Post: 轻松生活的十个小习惯">&laquo; 轻松生活的十个小习惯</a>
      
      
        <a class="basic-alignment right" href="/blog/2012/07/04/frontend-architecture/" title="next Post: frontend architecture">frontend architecture &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/07/05/interesting-js-puzzle/">interesting_js_puzzle</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/07/04/frontend-architecture/">frontend architecture</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/06/22/async-javascript/">async javascript</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/06/07/10-small-habits-of-less-stressed-people/">轻松生活的十个小习惯</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/06/05/callouts-and-quotes/">Callouts and Quotes</a>
      </li>
    
  </ul>
</section>






  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - zjhiphop -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
=======

<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>async javascript - Jade's fantastic Blog</title>
  <meta name="author" content="zjhiphop">

  
  <meta name="description" content="异步的javascript Ways to do this: Browser Ways: use timeout/interval/requestAnimationFrame
web worker
promise mode
nesting function Node ways: 1. use &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zjhiphop.github.com/blog/2012/06/22/async-javascript">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Jade's fantastic Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Jade's fantastic Blog</a></h1>
  
    <h2>Make a difference.Where amazing happens!</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:zjhiphop.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About </a></li> 
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Async Javascript</h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-22T14:33:00+08:00" pubdate data-updated="true">Jun 22<span>nd</span>, 2012</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>异步的javascript</p>

<h2>Ways to do this:</h2>

<h3>Browser Ways:</h3>

<ol>
<li>use timeout/interval/requestAnimationFrame</li>
<li>web worker</li>
<li>promise mode</li>
<li>nesting function</li>
</ol>


<h3>Node ways: 1. use process.nexttick</h3>

<p><a href="http://altjs.org/">alternative js</a></p>

<h2>Rules</h2>

<ul>
<li>avoid more than two levels of function nesting</li>
<li>Exceptionslive strictly in the land ofsynchronicity. When you reach the event queue,the stack is reset. Everystack trace is an unbroken chain of blocking code</li>
</ul>


<h2>Exceptions in callbacks</h2>

<ol>
<li>在定时器中异常发生时只有发生出的堆栈信息</li>
<li>定时器中的异常在外部不能捕获到，可以使用window.onerror来捕获所有的异常<br/>
 setTimeout(function A() {
 setTimeout(function B(){

<pre><code> try{
     setTimeout(function C(){
         throw new Error('Something ter-rible has happened!');
     },0);   
 }catch(e){
     console.log(e);//定时器中的异常捕获不到
 }
</code></pre>

<p> },0);
 },0);</p></li>
</ol>


<p>Tools<br/>
1. ES6<br/>
   *  iterators and generators, yield x</p>

<pre><code>    function simpleGenerator(){  
      yield "first";  
      yield "second";  
      yield "third";  
      for (var i = 0; i &lt; 3; i++)  
        yield i;  
    }  

    var g = simpleGenerator();  
    print(g.next()); // prints "first"  
    print(g.next()); // prints "second"  
    print(g.next()); // prints "third"  
    print(g.next()); // prints 0  
    print(g.next()); // prints 1  
    print(g.next()); // prints 2  
    print(g.next()); // StopIteration is thrown  
</code></pre>

<ol>
<li><a href="http://taskjs.org/">task.js</a></li>
<li><a href="https://githubcom/maxtaco/tamejs">TameJS</a>

<ul>
<li><blockquote><p>This package is a source-to-source translator that outputs JavaScript. The input dialect looks a lot like JavaScript, but introduces the await primitive, which allows asynchronous callback style code to work more like straight-line threaded code. tamejs is written in JavaScript.
One of the core powers of the tamejs rewriting idea is that it&#8217;s fully compatible with existing vanilla-JS code (like node.js&#8217;s libraries). That is, existing node.js can call code that&#8217;s been output by the tamejs rewriter, and conversely, code output by the tamejs rewriter can call existing node.js code. Thus, tamejs is incrementally deployable &#8211;you can keep all of your old code and just write the new bits in tamejs! So try it out and let us know what you think.</p></blockquote></li>
</ul>
</li>
<li><a href="http://onilabs.com/stratifiedjs">StratifiedJS</a>

<ul>
<li>StratifiedJS extends the JavaScript language with a small number of constructs for concurrent programming. It allows you to express asynchronous control flow in a straightforward sequential style: <br/>
var news;<br/>
waitfor {<br/>
news = http.get(&#8220;http://news.bbc.co.uk&#8221;);<br/>
}<br/>
or {<br/>
hold(1000);<br/>
news = http.get(&#8220;http://news.cnn.com&#8221;);<br/>
}<br/>
or {<br/>
hold(1000*60);<br/>
throw &#8220;sorry, no news. timeout&#8221;;<br/>
}<br/>
show(news);</li>
</ul>
</li>
<li><a href="http://weepy.github.com/kaffeine/">Kaffeine</a>

<ul>
<li><blockquote><p>Kaffeine is a set of extensions to the Javascript syntax that attempt to make it nicer to use. It compiles directly into javascript that is very similar, readable and line for line equivalent to the input (you can beautify if you like).</p></blockquote></li>
</ul>
</li>
<li><a href="https://github.com/Sage/streamlinejs">Streamline.js</a></li>
<li><a href="https://github.com/laverdet/node-fibers">node-fibers</a> Fiber/coroutine support for v8 and node</li>
</ol>


<h2>Distribute Events</h2>

<blockquote><p>where a single incident can trigger
reactions throughout our application.</p></blockquote>

<ol>
<li>PubSub/EventEmitter</li>
<li>evented models

<ul>
<li>BackBone.js</li>
</ul>
</li>
<li>JQuery custom events

<ul>
<li>Callbacks</li>
<li>Namespaced Events</li>
</ul>
</li>
<li><a href="LucidJS">LucidJS</a>

<ul>
<li><blockquote><p>Lucid is an uber simple and easy to use event emitter library. Lucid allows you to create your own event system and even pipe in events from any number of DOM elements.</p></blockquote></li>
</ul>
</li>
</ol>


<blockquote><p>Some applications, particularly Node servers,<strong>use a single global PubSub object to connect otherwise isolated modules,enabling loose coupling and easy testing.</strong> Thegreat thing about PubSubis that when you’re not subscribing tothe events that are being published, it’s completely unobtrusive.</p></blockquote>

<h2>Promises and Deferreds</h2>

<blockquote><p>A Promiseis an object that represents a
task with two possible outcomes(successor
failure) and holds callbacks that fire when
one outcome or the other has occurred.
But the biggest advantage of using Promises
is that you can easily derive new Promises
from existing ones.You might ask two Promises representing parallel tasks to give you a
Promise that will inform you of their mutual
completion.Or you might ask a Promise representing the first task in aseries to give you
a Promise representing the final task in the
series.</p>

<pre><code>var promise = $.get('/mydata');
promise.done(onSuccess);
promise.fail(onFailure);
promise.fail(onAlways);
</code></pre></blockquote>

<h3><a href="http://wiki.commonjs.org/wiki/Promises/A">Promise/A spec</a></h3>

<ul>
<li><a href="https://github.com/kriskowal/q">KrisKowal’sQ.js</a>

<blockquote><p>Qis a fairly straightforward
implementation of the Promises/Aspec</p></blockquote></li>
<li><a href="https://github.com/coolaj86/futures">AJONeal’s Futures</a>

<blockquote><p>Futures is a broader toolkit, incorporating
manyofthe flow control features found in
libraries like Async.js</p></blockquote></li>
<li><a href="http://api.jquery.com/category/deferred-object/">jQuery 1.5’s Promises</a>

<ul>
<li>Every Deferred has a single Promise,and every Promise represents a Deferred.</li>
<li>You can trigger a Deferred directly.</li>
<li>jQuery 1.6+ provide one more source of Promises: ordinary jQuery objects.</li>
<li>Promises let us see concurrent tasks as booleans.

<ul>
<li>The most common use case for logically combining Promisesis finding out when a set of async tasks have finished.</li>
<li>$.when is logical AND</li>
<li>Implements NOT

<pre><code>function not(promise) {
  var result = new  $.Deferred(); 
  promise.done(result.reject);
  promise.fail(result.resolve); 
  return result; 
}
</code></pre></li>
<li>Implements OR

<pre><code>function or() {
    var promises=Array.prototype.slice.call(arguments); 
    var negatedPromises=promises.map(not);
    return not($.when.apply(this,negatedPromises));
}
</code></pre></li>
<li>Why?

<ol>
<li>When a Promise passed to or is resolved, its negation will be rejected,
as will the Promise returned by
$.when, and thus the Promise returned by or willbe immediately
resolved.</li>
<li>When all of the Promises passed to
and are rejected,their negations will
all be resolved, as will the Promise
returned by $.when, and thus the
Promise returned by or will be
rejected.</li>
</ol>
</li>
</ul>
</li>
<li>Deferred VS Promise

<ul>
<li>The most obvious differenceis that the then
method in faithful Promises/A implementations like Q.js returns a new Promise that
represents the eventual return value of the
success/failure handler. It’s a lot like
jQuery’s pipe method.</li>
<li>Another big difference, previously mentioned,is that jQuery uses the term “resolve” as he opposite of “fail,”whereasPromises/A      uses “fulfill.” Under Promises/A,a Promise  is said to be “resolved” when it’s either fulfilled or failed.</li>
<li>There are other,subtler differences as well.
For instance: In Promises/A, whether a
Promise returned then is fulfilled or rejected depends on whether the invoked callback
returns a value or throws an error.(Throwing errors from jQuery Promise callbacksis a
bad idea, as they’ll go uncaught.)</li>
</ul>
</li>
<li>When to use?

<ul>
<li>Ajax</li>
<li>animation</li>
<li>notification</li>
<li>progress</li>
<li>anthing need callback(s)</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2><a href="http://en.wikipedia.org/wiki/Flow_control">Flow control</a> with <a href="https://github.com/caolan/async">Aync.JS</a></h2>

<pre><code>Conditional Statements

    if statements
    if ... else ... statements 

Looping Statements

    while loops
    do ... while loops 

switch Statements

label Statements

with Statements 
</code></pre>

<h3>The async ordering problem</h3>

<ul>
<li>Example

<ul>
<li><p>Read all files content in a dir,we must make sure all contents is correct readed</p>

<p>  var fs = require(&#8216;fs&#8217;);<br/>
  var concatenation=&#8221;;<br/>
  fs.readdirSync(&#8216;recipes&#8217;)<br/>
  .filter(function(filename){</p>

<pre><code>  return fs.statSync(filename).isFile();  
</code></pre>

  })<br/>
  .forEach(function(filename){

<pre><code>  concatenation+=fs.readFileSync(filename,'utf8')  
</code></pre>

<p>  });<br/>
  console.log(concatenation);</p></li>
</ul>


<p>  Or</p>

<pre><code>  var fs = require('fs');
  var concatenation='';
  var dirContents=fs.readdirSync('recipes');
  function readFileAt(i){
      if(i===dirContents.length)return 
       console.log(concatenation);
      fs.stat(filename,function(err,stats){
          if(err)throw err;
      if(!stats.isFile())return readFileAt(i+1);
          fs.readFile(dirContents[i],'ut-f8',function(err,fileContents){
      if(err)throw err;
          concatenation+=fileContents;
          readFileAt(i+1);
      });
      });
  }
  readFileAt(0);
</code></pre></li>
<li>We need async series method

<ul>
<li>First,there’s a limit on the number of files    that Node(or any application process) can try to read simultaneously.</li>
<li>Second,if we ran the readFile callback in
parallel, we couldn’t just write concatenation += fileContents;</li>
<li>So we stick to async.forEachSeries for now  <br/>
<strong>var async= require(&#8216;async&#8217;); <br/>
var fs=require(&#8216;fs&#8217;); <br/>
var concatenation=&#8221;; <br/>
var dirContents=fs.readdirSync(&#8216;recipes&#8217;); <br/>
async.filter(                                           dirContents,isFilename,function(filenames){ <br/>
async.forEachSeries(   filenames,readAndConcat,onComplete); <br/>
}); <br/>
function onComplete(err){ <br/>
if(err)throw err; <br/>
  console.log(concatenation); <br/>
} <br/>
function isFilename(filename,callback){ <br/>
fs.stat(filename,function(err,stats){ <br/>
  callback(err?false:stats.isFile()); <br/>
}); <br/>
} <br/>
function readAndConcat(filename,callback){ <br/>
fs.readFile(filename,&#8217;utf8&#8217;,function(   err,fileContents){ <br/>
  if(err)return callback(err); <br/>
  concatenation+=fileContents; <br/>
  callback(); <br/>
}); <br/>
}</strong></li>
</ul>
</li>
<li>array utilities in async.js

<ul>
<li>reject/rejectSeries, the inverse of filter</li>
<li>map/mapSeries, for 1:1 transformations</li>
<li>reduce and reduceRight, for transforming a value at each step</li>
<li>detect/detectSeries, for finding a value matching a filter</li>
<li>sortBy, for generating a sorted copy</li>
<li>some for testing whetheratleast one value matches the given criterion</li>
<li>ever for testing whether all values match the given criterion</li>
</ul>
</li>
<li>Error-handling in Async.js

<ul>
<li>Async.js uses Node-style callbacks:The first
callback argumentis an error.</li>
</ul>
</li>
<li>Chaining async functions

<ul>
<li>async.series provides only the call-back to each task</li>
<li>async.waterfall provides the results from the previous task.<br/>
<strong>
var async= require(&#8216;async&#8217;);<br/>
var fs=require(&#8216;fs&#8217;);<br/>
var concatenation=&#8221;;<br/>
var fileTasks=fs.readdirSync(&#8216;recipes&#8217;)<br/>
.filter(function(filename){<br/>
 return fs.statSync(filename).isFile();<br/>
})<br/>
.map(function(filename,i){<br/>
return function(callback){<br/>
fs.readFile(file-name,&#8217;utf8&#8217;,callback);<br/>
};<br/>
});<br/>
async.series(fileTasks,func-tion(err,results){
if(err)throw err;<br/>
console.log(concatenation=results.join(&#8221;));<br/>
});<br/>
</strong></li>
<li>If any of our readFile attempts did cause an error,the series would terminate and our completion handler would be called with the error immediately.</li>
</ul>
</li>
<li>Parallelizing async functions

<ul>
<li>async.parallel it takes an array of func-tions of the form function(callback) {&#8230;}, plus an(optional) completion handler.</li>
</ul>
</li>
<li>All at once, or one at a time?

<ul>
<li>The task array is static. Once you’ve called async.series or async.parallel, you can’t add or remove tasks.</li>
<li>There’s also no way to ask, “How many tasks have been completed?”It’s   a black box,unless you dispatch updates from the tasks themselves.</li>
<li>You’re limited to either no concurrency or unlimited concurrency.</li>
</ul>
</li>
<li>Dynamic async queueing

<blockquote><p>async.queue’s interface is a bit more complex than that of async.series and async.parallel. It takes a function called the worker(rather than an array offunc-tions) and a concurrency value(the maximum number of simultaneous tasks the work-ercanprocess).Thenit returns a queue that
we can push arbitrary task data onto(along
with an optional callback).<br/>
  * example</p></blockquote>

  function worker(data,callback){<br/>
  console.log(data);<br/>
  callback()<br/>
  }<br/>
  var concurrency=4;<br/>
  var queue=async.queue(worker,concurrency);<br/>
  queue.push(1);<br/>
  queue.push(2);<br/>
  queue.push(3);

<ul>
<li>When it’s all done

<ul>
<li>drain

<blockquote><p>(Picture a tub full of tasks;when the last one has gone down the drain,the callack fires.)</p></blockquote></li>
<li>  queue.drain=function(){
  (console.log(&#8216;queue Completed in &#8216;+(new Date()-start)+&#8217;ms&#8217;);
  };</li>
</ul>
</li>
<li>use queue to search content<br/>
var async= require(&#8216;async&#8217;);
var fs=require(&#8216;fs&#8217;);
var concatenation=&#8221;;
var filenames=fs.readdirSync(&#8216;recipes&#8217;)
.filter(function(filename){
return fs.statSync(filename).isFile();
});
function worker(i,callback){
fs.readFile(filenames[i],&#8217;utf8&#8217;,function(err,result){
if(err)throwerr;
results[i]=result;
callback();
});
}
var concurrency=10;
var queue=async.queue(worker,concurrency);
var results=[];
for(vari=0;i&lt;file-names.length;i++){
queue.push(i);
}
queue.drain=function(){
console.log(concatenation=results.join(&#8221;));
};</li>
<li>Advanced queue callbacks

<ul>
<li>When  the  last  task  has  started  running,  the  queue  calls  empty.  (When the task finishes, it calls drain.)</li>
<li>When the concurrency limit is              reached, the queue calls saturated.</li>
<li>If  you provide a function as  the second  argument  in  a  push,  it’ll  be called  when  the  given  task (or  each task in the given array) is finished.</li>
</ul>
</li>
<li>Somting Qeuene can&#8217;t do

<ul>
<li>example

<ol>
<li>Read a configuration file</li>
<li>Connect to the database specified by
the configuration file</li>
<li>Connectto the cache specified by the
configuration file</li>
<li>Loadthe most used objects from the
database into the cache</li>
<li>Connect to an external API</li>
<li>Start responding to HTTP requests</li>
</ol>
</li>
<li>solution

<ul>
<li>Promise whens and thens</li>
<li>async.auto

<ul>
<li>example <br/>
  async.auto({

<pre><code>readConfigFile:readConfigFile,
connectToDB:
['readConfigFile',connectToDB],
connectToCache:['readConfigFile',connectToCache],
cacheObjects:
['connectToDB','connectToCache',cacheObjects],
connectToAPI: connectToAPI,
</code></pre>

<p>  acceptHTTPReqs:[&#8216;connectToDB&#8217;,&#8217;connectToCache&#8217;,&#8217;connectToAPI&#8217;,
  acceptHTTPReqs]
  });</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>alternative

<ul>
<li><p><a href="https://github.com/creationix/step">TimCaswell’s Step</a></p>

<blockquote><p>Stepis much lighter
  than Async.js,with an API consisting of a
  single function: Step. Step takes alist of
  functions, e.g.
  Step(task1, task2, task3);</p></blockquote></li>
<li><p><a href="https://github.com/coolaj86/futures">Futures</a></p></li>
<li><a href="https://github.com/nakamura-to/nue">nue</a></li>
<li><a href="https://github.com/isaacs/slide-flow-control">slide</a>

<h2>Multi-threading with Workers</h2></li>
<li><p>Web Workers</p>

<blockquote><p>WebWorkers are part of the living standard
  widely known as HTML5.To create one,you
  call the global Worker constructor with the
  URL of a script:</p></blockquote>

<pre><code>  var worker = new Worker('kimptoc.js');
  worker.addEventListener('error',function(){
  console.log('Ch
  failed to load.');
  });   
</code></pre>

<ul>
<li>Talking to Web Workers

<ul>
<li>self.postMessage</li>
</ul>
</li>
<li>Restrictions on Web Workers

<ul>
<li>Performing physics calculations for
games with CoffeePhysics.</li>
<li>Decoding video as it streams in with
the Broad way implementation of the
H.264 codec.</li>
<li>Encrypting communications with the
Stanford JavaScript Crypto Library</li>
<li>updatethe page.</li>
<li>can’tseethe global window object</li>
</ul>
</li>
<li>importScripts will(synchronously) load and run the given script(s)</li>
<li>browsers support WebWorkers

<ul>
<li>Chrome</li>
<li>FF</li>
<li>Safari</li>
</ul>
</li>
</ul>
</li>
<li><p>Node Workers with cluster</p>

<ul>
<li>Typically,cluster is used to spin up one
process per CPU core for optimal perform-ance(though whethe reach process will actu-allygetits own core is entirely upto the un-derlying OS):</li>
</ul>


<p>  var cluster = require(&#8216;cluster&#8217;);
  if(cluster.isMaster){
  // spin up workers
  var coreCount=require(&#8216;os&#8217;).cpus().length;
  for(vari=0;i&lt;coreCount;i++){
  cluster.fork();
  }
  // bind death event
  cluster.on(&#8216;death&#8217;,func-tion(worker){
  console.log(&#8216;Worker
  &#8216;+worker.pid+&#8217; has died&#8217;);
  });
  }else{
  // die immediately
  process.exit();
  }</p>

<ul>
<li>child_process.fork</li>
<li>Talking to Node Workers</li>
</ul>


<p>  var  cluster = require(&#8216;cluster&#8217;);
  if(cluster.isMaster){
  // spin up workers
  var coreCount=require(&#8216;os&#8217;).cpus().length;
  for(var i=0;i&lt;coreCount;i++){
  var worker=cluster.fork();
  worker.send(&#8216;Hello, Worker!&#8217;,2);
  worker.on(&#8216;message&#8217;,function(message){
  if(message._queryId)return;
  console.log(message);
  });
  }
  }else{
  process.send(&#8216;Hello, mainprocess!&#8217;);
  process.on(&#8216;message&#8217;,function(message){
  console.log(message);
  });
  }</p>

<ul>
<li>Restrictions on Node Workers

<blockquote><p>For the most part,cluster obeys the same
rules as WebWorkers:There’s a master,and
there are Workers;they communicate via
events with attached strings orserializable objects. However, while Workers are obviously second-class citizens in the  browser, Node’s Workers possess all the rights and privileges of the master except</p></blockquote>

<pre><code>1. The ability to shut down the application,
2. The ability to spawn more Workers,
and
3. The ability to communicate with each other.
</code></pre>

<ul>
<li><a href="https://github.com/fent/clusterhub">Clusterhub</a>

<blockquote><p>Clusterhubprovides a hub object to each
process that acts as an inter-process
EventEmitter and EventVat store</p></blockquote>

<ul>
<li><a href="https://github.com/hij1nx/EventVat">EventVat</a></li>
<li>  // master
  varhub=require(&#8216;clusterhub&#8217;);
  hub.set(&#8216;hitCount&#8217;,0);
  // Workers
  varhub=require(&#8216;clusterhub&#8217;);
  functiononRequest(){
  hub.in-cr(&#8216;hitCount&#8217;,func-tion(hitCount){
  // &#8230;
  });
  }</li>
</ul>
</li>
<li>Temporary threads

<ul>
<li>single block of synchronous code to be run in a  separate  thread</li>
<li>create  and manage a pool of  Web Workers</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>Async Problems and Solutions</h2>

<h3>Problem: Where’d this go?</h3>

<p>It’s  a  rite  of  passage  for  JavaScripters:  You pass  a  callback.  You  use  this in  that  callback,not  giving  the matter  much  thought.
You spend  the  next  several  hours  trying  to figure out why your code is broken and cursing the day you were born. Or, at least, you join  one of the thousands who’ve  posted  examples like this to Stack Overflow:</p>

<pre><code>    // each button has data indicating an "action" to take 
    $('button').click (function (){ 
    $(this).after ('&lt;a href="#" 
    id="confirm"&gt;Confirm&lt;/a&gt;'); 
    $('#confirm').click (function (){ 

    var action = $(this).data ('action'); 
         // why is action undefined???
    });
    });
</code></pre>

<p>jQuery bears some responsibility for the confusion.  Devs  who  are  unaware  of the call
and apply methods that can warp it to anything  a function’s caller desires expect  this to scope like an ordinary variable,  albeit one mysteriously  set  in  their  event  handlers  via dark magicks. But the problem also arises in ordinary setTimeouts:</p>

<pre><code>    var account = { 
    balance :500, 
    showBalance:function (){console.log (this.balance); } 
    }; 
    account.showBalance()
    setTimeout(account.showBalance, 0);// undefined 
</code></pre>

<p>account.showBalance() calls  the  method  in  the account context,  but when account.showBalance is  passed  to a  function, the original context is lost.</p>

<ul>
<li><p>Solution 1: Capture this</p>

<p>  The  most  common  solution to  this  problem
  is to simply store the value of this that you
  want  in  a  separate variable.  Traditionally,  a
  name like  selfis used, but I prefer a clearer
  identifier:</p>

<pre><code>  $('button').click (function () { 
    var button = this; 
    $(button).after ('&lt;a href="#" 
  id="confirm"&gt;Confirm&lt;/a&gt;')
  $('#confirm').click (function (){ 
   var action = $(button).data ('action'); 
      // works! 
     }); 
   }); 
</code></pre>

<p>  This works for our  setTimeout example as
  well: Just change showBalanceto</p>

<pre><code>  showBalance: function () { console.log (account.balance); } 
</code></pre></li>
<li><p>Solution 2:
Bind callbacks to this JavaScripters have long known that a function can be made impervious to the dark magicks of call and apply by wrapping them in another function.Utility libraries like Underscore.js include a bind method for just such a purpose:</p>

<pre><code>   $('button').click (function () { 
     $(this).after ('&lt;a href="#" 
   id="confirm"&gt;Confirm&lt;/a&gt;'); 
     $('#confirm').click (_ .bind (function (){ 

   var action = $(this).data ('action'); 
      // works! 
     },this)); 
   }); 
</code></pre>

<p>What we’ve done here is forced the inner callback to have the same value of this as the outer one. This is such a common pattern that CoffeeScript makes it as easy as declaring the bound function with  => instead of  ->.  In newer JS runtimes (cutting-edge browsers and Node),the bind method is part of the function prototype itself,  so we could write:</p>

<pre><code>  $('#confirm').click ((function () { 
     ... 
   }).bind (this)); 
</code></pre></li>
</ul>


<p>Binding is widely used but slightly controversial.  It’s generally less efficient than capturing this, and has a tendency to complicate stack traces. See Patrick Mueller’s blog post “<a href="http://pmuellr.blogspot.com/2010/06/bind-considered-harmful.html">bind() considered harmful.</a>”  Perhaps more importantly,  when some callbacks are bound  and  others  aren’t,  it  tends  to  exacerbate  confusion about what  this is at a particular line of code.</p>

<ul>
<li><p>Solution 3: Work around this This solution only applies to jQuery, as most libraries are content to allow this in callbacks to take its default value, the root object (window in browsers, global in Node).
jQuery is not, and some prominent JavaScript developers (including Jeremy Ashkenas, creator of CoffeeScript and Backbone.js) have called that a mistake. Although most jQuery coders use this to get the DOM element that an event was fired from, you can use the less ambiguous e.currentTarget instead (where e is the event object that jQuery passes as the first argument to the handler):</p>

<pre><code>   $('button').click (function (e) { 
   $(e.currentTarget).after ('&lt;a 
  href="#" 
  id="confirm"&gt;Confirm&lt;/a&gt;'); 
    $('#confirm').click (function (){ 

   var action = $(e.currentTarget).data ('action'); 
      // works! 
     }); 
   }); 
</code></pre>

<p>Of course, e is just as prone to overuse as this, so consider using a distinguishing identifier like buttonEvent instead.</p></li>
</ul>


<h3>Problem: Retrying async tasks</h3>

<p>Often, we’ll want to attempt an async task n times before declaring failure, particularly when the task involves connecting to a remote server.  The basics of this problem are obvious:
1.  We need to store the number of failed attempts
2.  When an attempt fails, we need to increment the number of failed attempts and check whether it exceeds the maximum This translates into a lot of boilerplate code that we don’t want to repeat every time we run into this scenario, e.g.</p>

<pre><code>    var callback, failedAttempts = 0, asyncTask (callback = function (err) { 
      if (err) { 
         failedAttempts++; 

     if (failedAttempts &gt;=maxAttempts) { 
           failCallback(err); 
         }else { 
          asyncTask (callback); 
         }; 
       }else { 

     successCallback (Array.prototype .slice.call (arguments, 1)); 
       }; 
     }); 
How can we make this simple? 
</code></pre>

<ul>
<li>Solution 1:
Callback-style Assuming that we’re using Node-style callbacks, we can translate our boilerplate above into a reusable utility function:

<pre><code>   function attemptAndRetry (asyncTask, maxAttempts, callback) { 
    asyncTask (function (err) { 
      if (err) { 
        if (maxAttempts &lt;= 1) { 
          callback (err); 
        }else { 

   attemptAndTry (asyncTask,maxAttempts 1,callback); 
        }; 
      }else { 

   callback (null,Array.prototype .slice.call (arguments 
    }; 
     }); 
   } 
</code></pre></li>
</ul>


<p>Notice that we’re using quasi-recursion here.
There’s no risk of exceeding the stack limit, as long as asyncTask’s callback runs from the event queue.</p>

<p>This is the most direct solution, but there are a couple of things I don’t like about it.  For one, calling the function is a tad awkward:</p>

<pre><code>    attemptAndRetry (function (callback) { 
      fs.readFile ('locked.txt', 'utf8',callback); 
     },3,function (err,result) { 
      // ... 
     }); 
</code></pre>

<p>Another problem is that we don’t get finegrained control over the process.         For instance, what if we want to log the error on each failed attempt?</p>

<ul>
<li>Solution 2:
PubSub-style As is so often the case in JavaScript, the best solution is an EventEmitter.  It allows us to expose an extremely versatile API from a simple function. To wit:

<pre><code>  var EventEmitter = require ('events').EventEmitter; 
  function attempt (asyncTask) { 
    var emitter = new EventEmitter (),results; 
    emitter.failedAttempts= 0; 
    function retry = function (){ 
  asyncTask (function (err) { 
        if (err) { 
          emitter.failedAttempts++; 

   emitter.emit ('failure',err,retry); 
        }else { 

   results = Array.prototype .slice.call (arguments, 1); 

   emitter.emit ('success',results); 
        } 
       }); 
     } 
    process .nextTick (retry); // ensure asynchronicity return emitter; 
   } 
</code></pre></li>
</ul>


<p>This may be a little more complicated than our earlier definition, but it makes things extremely easy for the caller:</p>

<pre><code>    var reading = attempt (function (callback) { 
      fs.readFile ('locked.txt', 'utf8',callback); 
     }); 
    reading.on ('failure',function (err,retry) { 
      console.error (err); 
      if (reading.failedAttempts&lt; 3)retry (); 
     }); 
    reading.on ('success',function (contents) { 

     // ... 
     }); 
</code></pre>

<p>Now we have cleanly exposed state and precise control over when we retry our function.
Plus, because we can attach multiple handlers for the same event, it’s easy to view the process state from multiple perspectives. We could, for example, map the task onto a Promise for easy monitoring:</p>

<pre><code>    var deferred = new $.Deferred (); 
    reading.on ('failure',function (err,retry) { 
      if (reading.failedAttempts &gt;= 3)deferred.reject (err); 
     }); 
    reading.on ('success',deferred.resolve) 
</code></pre>

<p> ###Problem: Testing async code In languages like Java and Ruby, test cases can just be lists of assertions. Unfortunately, that won’t cut it when testing async JavaScript code, because the test runner has no way of knowing when the test case is complete. It’s important to use a JavaScript testing framework that can handle async test cases and produce meaningful output despite the unpredictable order of assertions.</p>

<ul>
<li>Solution: Use Mocha The successor to Expresso, Mocha is a onesize-fits-all testing framework for both the browser and Node.  While async testing was something of a pain in older testing frameworks like QUnit (requiring async test cases to manually start and stop the runner), Mocha makes it  “just work.”  Here’s an example using Mocha’s T        -style interface (which I prefer for its simplicity over the default Bstyle interface):

<pre><code>  var assert = require ('assert'); 
  suite('gamification',function (){ 
    setup(gamify); 
    test ('gamify resets points',function (){ 
      assert.equal (points, 0); 
     }); 
    test ('player points are loaded on login',function (done) { 
      assert.equal (points, 0); 

   login (mock .username,mock .password,function (err,success) { 
        if (err)throw err; 
        assert.ok (success); 

   assert.equal (points,mock .points); 
     done (); 
       }); 
     }); 
   }); 
</code></pre></li>
</ul>


<p>Assume the assertions all pass.     When this code is run, via the command mocha  -u tdd test.js, the test runner will report the first test case’s success as soon as it returns, and will report the second test case’s success as soon as it calls done.         But wait—how did it know to wait for done to be called in the second case?</p>

<p>The magic here is in a JavaScript feature called arity.  The arity of a function is the number of declared arguments it takes. That number is exposed as the lengthproperty:</p>

<pre><code>(function () 
 { ... }).length;  // 0 (function (done) { ... }).length; // 
</code></pre>

<p>1 Using this to distinguish synchronous functions from async ones is a clever hack, though it comes with a caveat: If you accidentally declare a synchronous test case with an argument, e.g.</p>

<pre><code>    test ('bedard', function (done) { 
      assert.ok (true); 
     }); 
</code></pre>

<p>you’ll get the error output x 1 of 1 tests failed: 1)  bedard: Error: timeout of 2000ms exceeded Usually, declaring functions without unnecessary arguments is good style.  In Mocha, it’s a matter of life or death.</p>

<h3>Problem:</h3>

<p>Aggregating events With the rise of evented models, it’s become easy to oversaturate an application with events, slowing it to a crawl. For instance, in a game, we might represent each of thousands of characters in a level with a Backbone model and perform game logic in response to any changes in those models.  But when the player throws a grenade that blows up 100 monsters at once, we don’t want to perform the same logic 100 times.  How can we avoid this?</p>

<ul>
<li>Solution 1:
Silence the change events Backbone gives us a special flag that we can use to change models without them emitting a  &#8216;change&#8217;event:

<pre><code>  monsters.each (function (damage) { 
    this.set({life:this.get ('life')age}, {silent:true}); 
   }); 
</code></pre></li>
</ul>


<p>Used carefully, this is the most efficient solution to our problem. But it’ll only work if we have absolute knowledge about what’s supposed to happen when each model we’re silently modifying changes.</p>

<p>Silencing events is like a scalpel. With steady hands and precise planning, it can be an invaluable tool;  otherwise, it’s just going to make a mess.</p>

<ul>
<li>Solution 2:
Use a simple timeout Remember that even a 0ms delay will ensure that a function runs after all synchronous code.  We can use that to our advantage by having a checkGameState function runs just once after all of the individual monster models have been updated:

<pre><code>  var checkGameStateTimeout; 
   function checkGameState (){ 
     // if no monster allies remain, you lose var isTheGameLost= monsters .filter (function (){ 
      return this.get ('ally'); 
     }).length=== 0; 
     // and so on... 
  } 
  var monsters = new Backbone.Collection; 
  monsters .on ('change',function (){ 
    clearTimeout (checkGameStateTimeout); 
    checkGameStateTimeout = setTimeout( 
  GameState, 0); 
   }); 
</code></pre></li>
</ul>


<p>Now no matter how many monsters are changed simultaneously, checkGameState will fire just once in response.</p>

<ul>
<li>Solution 3:
Throttling/Debouncing We’ve looked at one solution that operates from the part of the app that updates the models and another that works from the models’ end.  But the most elegant approach is usually to act on the particular function that we want to prevent from being called too often.  In general terms, that means we want to limit checkGameState to running once every n milliseconds. There are two basic approaches to this:</li>
<li>Throttling, where additional calls to the function are ignored if its last run was less than n ms ago, and</li>
<li>Debouncing, where any call to the function is delayed until n ms have elapsed since the last call Usually, you want throttling, because debouncing adds some latency to every function call.    Plus, debouncing means that a function will never be called if it’s called too often! (Sometimes debouncing is implemented with a maximum delay to avoid this.)
However, debouncing is preferable in scenarios where you want to wait until an input source is idle, such as rendering a preview or running a validation only after the user has momentarily stopped typing.</li>
</ul>


<p>Both throttling and debouncing are easy to implement by creating a meta-function that returns a wrapped version of the original function.Here are two simple implementations:</p>

<pre><code>    function throttle (func, minDelay) { 
      var lastHitDate = 0; 
      return function (){ 
        var now = new Date (); 

     if (now lastHitDate &gt;=minDelay) { 
          lastHitDate = now; 

     return func.apply (this,arguments); 
        }; 
    }; 
     } 

    function debounce (func, delay) { 
      var timeout; 
      return function (){ 
        var args = arguments; 
        clearTimeout (timeout); 
        timeout = setTimeout(function (){ 
          func.apply (this,args); 
         },delay); 
       }; 
     } 

(If you’re using Underscore.js—and you should!—you can just use _.throttle and _.debounce.) 
</code></pre>

<p>With these utility functions, we can either overwrite checkGameState entirely or just use the wrapped version from our change events.  For our purposes, debounce with a delay of 0 is most appropriate, since throttle with a short delay would allow checkGameState to run more within a block of synchronous code. debouncewith a delay of 0 is effectively equivalent to the setTimeoutwe used in solution 2:</p>

<pre><code>    var debouncedCheckGameState = debounce (checkGameState, 0); 
    monsters .on ('change',function (){ 
      debouncedCheckGameState (); 
     }); 
</code></pre>

<p>Note that it’s important to use the same throttled/debounced instance of a function from every source that we want to limit calls from. Calling (debounce (checkGameState, 0))();
would just be an overly complicated way of calling setTimeout(checkGameState, 0);</p>

<p>because calling debounce(checkGameState, 0) again would just create a separate timeout.</p>

<h3>Problem:</h3>

<p>Handling requests Quick question:
You’re a web server. You receive a request. What do you do?</p>

<p>Most likely, lots of unrelated things. At a minimum, you look at the requested route and map it to a file that you send in response. But you also probably log the request, check whether the requester is properly authenticated, and fetch some data. Maybe you cache the response in memory, too. Many of these pieces of functionality will be the same for some or all routes. How do you avoid duplication?</p>

<ul>
<li>Solution:
The middleware pattern In the Node.js Connect framework, each middleware function takes a request object (req), a response object (res), and a next callback. Every time a new request comes in, it’s passed to the first middleware. The middleware has three (good) options:</li>
<li>Handle the request itself by sending a response and returning without calling next.</li>
<li>Call nextwith no arguments.</li>
<li><p>Call nextwith an error argument. The next callback Connect generates either passes the request on to the next middleware on the stack, or to an error handler. And that’s basically all Connect does. This simple pattern (the core implementation is less than 200 lines) has proven so successful that just about every Node server framework has been built on top of Connect, most notably Express.js. Consider using the middleware pattern in other contexts where an action needs to be handled in several discrete steps. The only difference between a middleware stack and an ordinary callback stack (like we saw in Chapter 2) is that each function on the stack receives a next function that allows it to declare that it’s finished, making an async series of actions possible. Here’s a minimal implementation for comparison’s sake:</p>

<pre><code>// callback stack function trigger (){ 
  handlers.forEach(function (handler) { 
    handler (); 
   }); 
 } 
// middleware stack function trigger (){ 
  invoke (0); 
 } 
function invoke (idx) { 
  if (handlers.length&lt;= idx) { 
    return; 
   }else { 
    handlers [idx](function (err) { 
      if (err)throw err; 

 if (handlers.length &gt; idx + 1)invoke (idx + 1); 
   }; 
} 
</code></pre></li>
</ul>


<p>Perceptive readers may be reminded of async.series from Chapter 4. Connecting functions this way is an extremely common pattern. Feel free to reinvent the wheel, but be aware that the wheel is already available under the MIT License.</p>

<h3>Problem:Ajax spaghetti</h3>

<p>Consider this an integrative exercise. How do we turn highly nested code like this into something clearer, better-organized, less repetitive, and easier to modify if we decide to change our application’s behavior?</p>

<pre><code>    $(function () { 
      $('#menu').on ('click', 'a',function clickHandler (){ 
        // we put a spinner on the selected menu item var $clickedLink= $(this).spin(); 
        // we disable the menu until our Ajax call returns 
        $('#menu').off ('click', 'li &gt; 
    a'); 

     $.get ('/content/'+ $clickedLink. success:function successHandler(response) { 
            $clickedLink.unspin (); 
            $('#menu').on ('click', 'li &gt; 
    a',clickHandler); 
            // we fade the content out... 

     $('#content').fadeOut(function (){ 
              // ...then we fade it in with the Ajax markup 

     $('#content').html (response).fadeIn(); 
            }); 
          }, error:function (){ 
            // we make one retry in case the error is just a fluke 
    $.get ('/content/' + $clickedLink.index (),{ 
              success:successHandler, error:function (){ 
                $clickedLink.unspin (); 
                $('#menu').on ('click', 'li &gt; 
    a',clickHandler); 
               modal ('Error retrieving content from the server.'); 
              } 
            }); 
          } 
        }); 
        return false; // prevent default click behavior 
      }); 
    }); 
</code></pre>

<ul>
<li>Solution:
Distribute, distribute, distribute The big problem with the code above is that it’s way too centralized. Everything that happens in response to a menu click goes in the click handler, and everything that happens in response to the Ajax request goes in the Ajax response handler. We need to spread things out in a way that makes sense. There are plenty of ways we could do that here—using custom jQuery events, for example—but the approach I’d recommend is using an evented model to represent the menu. The model will encapsulate the state that we need to capture from the various async events, and the abstraction will make it easy for us to change our event flow in the future. Let’s start by asking, “What state do we need to store?” I can think of three things:</li>
<li>Whether our menu is in its  “ready,”
clickable state, or in the     “unready”<br/>
state with a spinner over the active link.</li>
<li>Which link is currently active (in the process of having associated content loaded), if any.</li>
<li>How many attempts we’ve made so far to request content from the server for the active link. The first two sound like they should be associated with the menu. So that gives us our menu model:

<pre><code> window.menu = new Backbone.Model ({ 
   ready:false, activeLinkIndex:-1 
  }); 
</code></pre>

<p>Why does our menu start out with ready:
false? Because the menu element may not exist yet in the document. We want readyto correspond to the click handler being attached. We also want to ensure that there is no active link when the menu becomes ready:</p>

<pre><code>  menu .on ('change:ready', function (ready) { 
  if (ready) { 
  $('#menu').on ('click', 'li &gt; 
  a',menu .clickHandler); 
  menu .set('activeLinkIndex',-1); 
  }else { 
  $('#menu').off ('click', 'li &gt; 
  a'); 
  } 
  }); 
</code></pre></li>
</ul>


<p>Notice the reference to menu.clickHandler. For convenient namespacing, we’ll go ahead and attach all of our menu-related event handlers to the menu model:</p>

<pre><code>    menu .clickHandler = function () { 
      menu .set({ready:false,activeLinkIndex:$(this).index ()}); 
      return false; 
     } 
</code></pre>

<p>Declaring the menu ready is the only thing that has to wait for the DOM. So our jQuery callback, which originally wrapped around everything, is just a one-liner:</p>

<pre><code>    $(function () { menu .set({ready: 
    true}); 
</code></pre>

<p>(Note that it’s important for this line to come after menu.clickHandler is defined, because the callback will run synchronously if the document is already ready.)</p>

<p>The click handler modifies the menu’s activeLinkIndex, so let’s respond to that by fetching the appropriate content and adding the Ajax spinner to the correct menu item:</p>

<pre><code>    menu .on ('change:activeLinkIndex', function (activeLinkIndex) { 
      $('#menu').children ().unspin (); 
         .eq (activeLinkIndex).spin(); 
      menu .fetchSelectedContent(); 
     }); 
</code></pre>

<p>If activeLinkIndex is changed to  -1 (indicating that no link is active), the eq(activeLinkIndex) selector will match no elements, so no Ajax spinner will appear. And the first line of our fetchSelectedContentwill simply return:</p>

<pre><code>    menu .fetchSelectedContent = function () { 
      if (menu .get ('activeLinkIndex')=== -1)return; 
      $.ajax ({ 

     url: 
    '/content/'+menu .get ('activeLinkIndex'), tryCount:0 
       }) 
       .done ($('#content').fadeHtml) 
       .done (function (){menu .set({ready:true}); }) 
       .failure(function (){ 
        this.tryCount++; 
        if (this.tryCount &gt;= 2) { 
          modal ('Error retrieving content from the server.'); 
    }else { 
          $.ajax (this); 
         }; 
       });); 
     } 
</code></pre>

<p>This is our most complex function, but every line serves a clear purpose. When the Ajax call succeeds: <br/>
1. The content element’s fadeHtml method is called with the data retrieved from the server. fadeHtml is a simple plugin that we’ll define shortly.<br/>
2. The menu is restored to its ready state. Recall that this will also reset activeLinkIndexto 1. When the Ajax call fails:<br/>
1. this in a jQuery Ajax callback points to the jqXHR object that, among other things, stores all of the settings passed in to  $.ajax. We use that to store our tryCount.<br/>
2. Because this also contains our url property, we can simply write $.ajax(this) to reattempt the Ajax call. This technique was popularized by a blog post entitled  “Defensive Ajax and Ajax retries in jQuery.”</p>

<p>If we felt like the fetchSelectedContent method was too large, we could move the failure handler out of it. That’s the great thing about evented code:
As long as state is stored rationally, you have unlimited flexibility. Now the only gap left to fill in is to define fadeHtml:</p>

<pre><code>     $.fn.fadeHtml = function (markup) { 
      return this.fadeOut(function (){ 
        $(this).html (markup).fadeIn(); 
       }); 
     }; 
</code></pre>

<p>And that’s it! We have a little more code than we started with, but it’s many times easier to work with.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">zjhiphop</span></span>

      








  


<time datetime="2012-06-22T14:33:00+08:00" pubdate data-updated="true">Jun 22<span>nd</span>, 2012</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/thinking-in-js/'>thinking in JS</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://zjhiphop.github.com/blog/2012/06/22/async-javascript/" data-via="" data-counturl="http://zjhiphop.github.com/blog/2012/06/22/async-javascript/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2012/06/07/10-small-habits-of-less-stressed-people/" title="Previous Post: 轻松生活的十个小习惯">&laquo; 轻松生活的十个小习惯</a>
      
      
        <a class="basic-alignment right" href="/blog/2012/07/21/some-valueable-links/" title="next Post: Some Valueable Links">Some Valueable Links &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/07/21/some-valueable-links/">Some Valueable Links</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/06/22/async-javascript/">async javascript</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/06/07/10-small-habits-of-less-stressed-people/">轻松生活的十个小习惯</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/06/05/callouts-and-quotes/">Callouts and Quotes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/06/05/alerts/">Alerts</a>
      </li>
    
  </ul>
</section>






  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - zjhiphop -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
>>>>>>> 3d316c3e741c277d7dbd2d7d957017408ed31ac7
