<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: thinking in JS | Jade's fantastic Blog]]></title>
  <link href="http://zjhiphop.github.com/blog/categories/thinking-in-js/atom.xml" rel="self"/>
  <link href="http://zjhiphop.github.com/"/>
  <updated>2013-06-19T11:30:07+08:00</updated>
  <id>http://zjhiphop.github.com/</id>
  <author>
    <name><![CDATA[zjhiphop]]></name>
    <email><![CDATA[zjhiphop@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[async javascript]]></title>
    <link href="http://zjhiphop.github.com/blog/2012/06/22/async-javascript/"/>
    <updated>2012-06-22T14:33:00+08:00</updated>
    <id>http://zjhiphop.github.com/blog/2012/06/22/async-javascript</id>
    <content type="html"><![CDATA[<p>异步的javascript</p>

<h2>Ways to do this:</h2>

<h3>Browser Ways:</h3>

<ol>
<li>use timeout/interval/requestAnimationFrame</li>
<li>web worker</li>
<li>promise mode</li>
<li>nesting function</li>
</ol>


<h3>Node ways: 1. use process.nexttick</h3>

<p><a href="http://altjs.org/">alternative js</a></p>

<h2>Rules</h2>

<ul>
<li>avoid more than two levels of function nesting</li>
<li>Exceptionslive strictly in the land ofsynchronicity. When you reach the event queue,the stack is reset. Everystack trace is an unbroken chain of blocking code</li>
</ul>


<h2>Exceptions in callbacks</h2>

<ol>
<li>在定时器中异常发生时只有发生出的堆栈信息</li>
<li>定时器中的异常在外部不能捕获到，可以使用window.onerror来捕获所有的异常<br/>
 setTimeout(function A() {
 setTimeout(function B(){

<pre><code> try{
     setTimeout(function C(){
         throw new Error('Something ter-rible has happened!');
     },0);   
 }catch(e){
     console.log(e);//定时器中的异常捕获不到
 }
</code></pre>

<p> },0);
 },0);</p></li>
</ol>


<p>Tools<br/>
1. ES6<br/>
   *  iterators and generators, yield x</p>

<pre><code>    function simpleGenerator(){  
      yield "first";  
      yield "second";  
      yield "third";  
      for (var i = 0; i &lt; 3; i++)  
        yield i;  
    }  

    var g = simpleGenerator();  
    print(g.next()); // prints "first"  
    print(g.next()); // prints "second"  
    print(g.next()); // prints "third"  
    print(g.next()); // prints 0  
    print(g.next()); // prints 1  
    print(g.next()); // prints 2  
    print(g.next()); // StopIteration is thrown  
</code></pre>

<ol>
<li><a href="http://taskjs.org/">task.js</a></li>
<li><a href="https://githubcom/maxtaco/tamejs">TameJS</a>

<ul>
<li><blockquote><p>This package is a source-to-source translator that outputs JavaScript. The input dialect looks a lot like JavaScript, but introduces the await primitive, which allows asynchronous callback style code to work more like straight-line threaded code. tamejs is written in JavaScript.
One of the core powers of the tamejs rewriting idea is that it's fully compatible with existing vanilla-JS code (like node.js's libraries). That is, existing node.js can call code that's been output by the tamejs rewriter, and conversely, code output by the tamejs rewriter can call existing node.js code. Thus, tamejs is incrementally deployable --you can keep all of your old code and just write the new bits in tamejs! So try it out and let us know what you think.</p></blockquote></li>
</ul>
</li>
<li><a href="http://onilabs.com/stratifiedjs">StratifiedJS</a>

<ul>
<li>StratifiedJS extends the JavaScript language with a small number of constructs for concurrent programming. It allows you to express asynchronous control flow in a straightforward sequential style: <br/>
var news;<br/>
waitfor {<br/>
news = http.get("http://news.bbc.co.uk");<br/>
}<br/>
or {<br/>
hold(1000);<br/>
news = http.get("http://news.cnn.com");<br/>
}<br/>
or {<br/>
hold(1000*60);<br/>
throw "sorry, no news. timeout";<br/>
}<br/>
show(news);</li>
</ul>
</li>
<li><a href="http://weepy.github.com/kaffeine/">Kaffeine</a>

<ul>
<li><blockquote><p>Kaffeine is a set of extensions to the Javascript syntax that attempt to make it nicer to use. It compiles directly into javascript that is very similar, readable and line for line equivalent to the input (you can beautify if you like).</p></blockquote></li>
</ul>
</li>
<li><a href="https://github.com/Sage/streamlinejs">Streamline.js</a></li>
<li><a href="https://github.com/laverdet/node-fibers">node-fibers</a> Fiber/coroutine support for v8 and node</li>
</ol>


<h2>Distribute Events</h2>

<blockquote><p>where a single incident can trigger
reactions throughout our application.</p></blockquote>

<ol>
<li>PubSub/EventEmitter</li>
<li>evented models

<ul>
<li>BackBone.js</li>
</ul>
</li>
<li>JQuery custom events

<ul>
<li>Callbacks</li>
<li>Namespaced Events</li>
</ul>
</li>
<li><a href="LucidJS">LucidJS</a>

<ul>
<li><blockquote><p>Lucid is an uber simple and easy to use event emitter library. Lucid allows you to create your own event system and even pipe in events from any number of DOM elements.</p></blockquote></li>
</ul>
</li>
</ol>


<blockquote><p>Some applications, particularly Node servers,<strong>use a single global PubSub object to connect otherwise isolated modules,enabling loose coupling and easy testing.</strong> Thegreat thing about PubSubis that when you’re not subscribing tothe events that are being published, it’s completely unobtrusive.</p></blockquote>

<h2>Promises and Deferreds</h2>

<blockquote><p>A Promiseis an object that represents a
task with two possible outcomes(successor
failure) and holds callbacks that fire when
one outcome or the other has occurred.
But the biggest advantage of using Promises
is that you can easily derive new Promises
from existing ones.You might ask two Promises representing parallel tasks to give you a
Promise that will inform you of their mutual
completion.Or you might ask a Promise representing the first task in aseries to give you
a Promise representing the final task in the
series.</p>

<pre><code>var promise = $.get('/mydata');
promise.done(onSuccess);
promise.fail(onFailure);
promise.fail(onAlways);
</code></pre></blockquote>

<h3><a href="http://wiki.commonjs.org/wiki/Promises/A">Promise/A spec</a></h3>

<ul>
<li><a href="https://github.com/kriskowal/q">KrisKowal’sQ.js</a>

<blockquote><p>Qis a fairly straightforward
implementation of the Promises/Aspec</p></blockquote></li>
<li><a href="https://github.com/coolaj86/futures">AJONeal’s Futures</a>

<blockquote><p>Futures is a broader toolkit, incorporating
manyofthe flow control features found in
libraries like Async.js</p></blockquote></li>
<li><a href="http://api.jquery.com/category/deferred-object/">jQuery 1.5’s Promises</a>

<ul>
<li>Every Deferred has a single Promise,and every Promise represents a Deferred.</li>
<li>You can trigger a Deferred directly.</li>
<li>jQuery 1.6+ provide one more source of Promises: ordinary jQuery objects.</li>
<li>Promises let us see concurrent tasks as booleans.

<ul>
<li>The most common use case for logically combining Promisesis finding out when a set of async tasks have finished.</li>
<li>$.when is logical AND</li>
<li>Implements NOT

<pre><code>function not(promise) {
  var result = new  $.Deferred(); 
  promise.done(result.reject);
  promise.fail(result.resolve); 
  return result; 
}
</code></pre></li>
<li>Implements OR

<pre><code>function or() {
    var promises=Array.prototype.slice.call(arguments); 
    var negatedPromises=promises.map(not);
    return not($.when.apply(this,negatedPromises));
}
</code></pre></li>
<li>Why?

<ol>
<li>When a Promise passed to or is resolved, its negation will be rejected,
as will the Promise returned by
$.when, and thus the Promise returned by or willbe immediately
resolved.</li>
<li>When all of the Promises passed to
and are rejected,their negations will
all be resolved, as will the Promise
returned by $.when, and thus the
Promise returned by or will be
rejected.</li>
</ol>
</li>
</ul>
</li>
<li>Deferred VS Promise

<ul>
<li>The most obvious differenceis that the then
method in faithful Promises/A implementations like Q.js returns a new Promise that
represents the eventual return value of the
success/failure handler. It’s a lot like
jQuery’s pipe method.</li>
<li>Another big difference, previously mentioned,is that jQuery uses the term “resolve” as he opposite of “fail,”whereasPromises/A      uses “fulfill.” Under Promises/A,a Promise  is said to be “resolved” when it’s either fulfilled or failed.</li>
<li>There are other,subtler differences as well.
For instance: In Promises/A, whether a
Promise returned then is fulfilled or rejected depends on whether the invoked callback
returns a value or throws an error.(Throwing errors from jQuery Promise callbacksis a
bad idea, as they’ll go uncaught.)</li>
</ul>
</li>
<li>When to use?

<ul>
<li>Ajax</li>
<li>animation</li>
<li>notification</li>
<li>progress</li>
<li>anthing need callback(s)</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2><a href="http://en.wikipedia.org/wiki/Flow_control">Flow control</a> with <a href="https://github.com/caolan/async">Aync.JS</a></h2>

<pre><code>Conditional Statements

    if statements
    if ... else ... statements 

Looping Statements

    while loops
    do ... while loops 

switch Statements

label Statements

with Statements 
</code></pre>

<h3>The async ordering problem</h3>

<ul>
<li>Example

<ul>
<li><p>Read all files content in a dir,we must make sure all contents is correct readed</p>

<p>  var fs = require('fs');<br/>
  var concatenation='';<br/>
  fs.readdirSync('recipes')<br/>
  .filter(function(filename){</p>

<pre><code>  return fs.statSync(filename).isFile();  
</code></pre>

  })<br/>
  .forEach(function(filename){

<pre><code>  concatenation+=fs.readFileSync(filename,'utf8')  
</code></pre>

<p>  });<br/>
  console.log(concatenation);</p></li>
</ul>


<p>  Or</p>

<pre><code>  var fs = require('fs');
  var concatenation='';
  var dirContents=fs.readdirSync('recipes');
  function readFileAt(i){
      if(i===dirContents.length)return 
       console.log(concatenation);
      fs.stat(filename,function(err,stats){
          if(err)throw err;
      if(!stats.isFile())return readFileAt(i+1);
          fs.readFile(dirContents[i],'ut-f8',function(err,fileContents){
      if(err)throw err;
          concatenation+=fileContents;
          readFileAt(i+1);
      });
      });
  }
  readFileAt(0);
</code></pre></li>
<li>We need async series method

<ul>
<li>First,there’s a limit on the number of files    that Node(or any application process) can try to read simultaneously.</li>
<li>Second,if we ran the readFile callback in
parallel, we couldn’t just write concatenation += fileContents;</li>
<li>So we stick to async.forEachSeries for now  <br/>
<strong>var async= require('async'); <br/>
var fs=require('fs'); <br/>
var concatenation=''; <br/>
var dirContents=fs.readdirSync('recipes'); <br/>
async.filter(                                           dirContents,isFilename,function(filenames){ <br/>
async.forEachSeries(   filenames,readAndConcat,onComplete); <br/>
}); <br/>
function onComplete(err){ <br/>
if(err)throw err; <br/>
  console.log(concatenation); <br/>
} <br/>
function isFilename(filename,callback){ <br/>
fs.stat(filename,function(err,stats){ <br/>
  callback(err?false:stats.isFile()); <br/>
}); <br/>
} <br/>
function readAndConcat(filename,callback){ <br/>
fs.readFile(filename,'utf8',function(   err,fileContents){ <br/>
  if(err)return callback(err); <br/>
  concatenation+=fileContents; <br/>
  callback(); <br/>
}); <br/>
}</strong></li>
</ul>
</li>
<li>array utilities in async.js

<ul>
<li>reject/rejectSeries, the inverse of filter</li>
<li>map/mapSeries, for 1:1 transformations</li>
<li>reduce and reduceRight, for transforming a value at each step</li>
<li>detect/detectSeries, for finding a value matching a filter</li>
<li>sortBy, for generating a sorted copy</li>
<li>some for testing whetheratleast one value matches the given criterion</li>
<li>ever for testing whether all values match the given criterion</li>
</ul>
</li>
<li>Error-handling in Async.js

<ul>
<li>Async.js uses Node-style callbacks:The first
callback argumentis an error.</li>
</ul>
</li>
<li>Chaining async functions

<ul>
<li>async.series provides only the call-back to each task</li>
<li>async.waterfall provides the results from the previous task.<br/>
<strong>
var async= require('async');<br/>
var fs=require('fs');<br/>
var concatenation='';<br/>
var fileTasks=fs.readdirSync('recipes')<br/>
.filter(function(filename){<br/>
 return fs.statSync(filename).isFile();<br/>
})<br/>
.map(function(filename,i){<br/>
return function(callback){<br/>
fs.readFile(file-name,'utf8',callback);<br/>
};<br/>
});<br/>
async.series(fileTasks,func-tion(err,results){
if(err)throw err;<br/>
console.log(concatenation=results.join(''));<br/>
});<br/>
</strong></li>
<li>If any of our readFile attempts did cause an error,the series would terminate and our completion handler would be called with the error immediately.</li>
</ul>
</li>
<li>Parallelizing async functions

<ul>
<li>async.parallel it takes an array of func-tions of the form function(callback) {...}, plus an(optional) completion handler.</li>
</ul>
</li>
<li>All at once, or one at a time?

<ul>
<li>The task array is static. Once you’ve called async.series or async.parallel, you can’t add or remove tasks.</li>
<li>There’s also no way to ask, “How many tasks have been completed?”It’s   a black box,unless you dispatch updates from the tasks themselves.</li>
<li>You’re limited to either no concurrency or unlimited concurrency.</li>
</ul>
</li>
<li>Dynamic async queueing

<blockquote><p>async.queue’s interface is a bit more complex than that of async.series and async.parallel. It takes a function called the worker(rather than an array offunc-tions) and a concurrency value(the maximum number of simultaneous tasks the work-ercanprocess).Thenit returns a queue that
we can push arbitrary task data onto(along
with an optional callback).<br/>
  * example</p></blockquote>

  function worker(data,callback){<br/>
  console.log(data);<br/>
  callback()<br/>
  }<br/>
  var concurrency=4;<br/>
  var queue=async.queue(worker,concurrency);<br/>
  queue.push(1);<br/>
  queue.push(2);<br/>
  queue.push(3);

<ul>
<li>When it’s all done

<ul>
<li>drain

<blockquote><p>(Picture a tub full of tasks;when the last one has gone down the drain,the callack fires.)</p></blockquote></li>
<li>  queue.drain=function(){
  (console.log('queue Completed in '+(new Date()-start)+'ms');
  };</li>
</ul>
</li>
<li>use queue to search content<br/>
var async= require('async');
var fs=require('fs');
var concatenation='';
var filenames=fs.readdirSync('recipes')
.filter(function(filename){
return fs.statSync(filename).isFile();
});
function worker(i,callback){
fs.readFile(filenames[i],'utf8',function(err,result){
if(err)throwerr;
results[i]=result;
callback();
});
}
var concurrency=10;
var queue=async.queue(worker,concurrency);
var results=[];
for(vari=0;i&lt;file-names.length;i++){
queue.push(i);
}
queue.drain=function(){
console.log(concatenation=results.join(''));
};</li>
<li>Advanced queue callbacks

<ul>
<li>When  the  last  task  has  started  running,  the  queue  calls  empty.  (When the task finishes, it calls drain.)</li>
<li>When the concurrency limit is              reached, the queue calls saturated.</li>
<li>If  you provide a function as  the second  argument  in  a  push,  it’ll  be called  when  the  given  task (or  each task in the given array) is finished.</li>
</ul>
</li>
<li>Somting Qeuene can't do

<ul>
<li>example

<ol>
<li>Read a configuration file</li>
<li>Connect to the database specified by
the configuration file</li>
<li>Connectto the cache specified by the
configuration file</li>
<li>Loadthe most used objects from the
database into the cache</li>
<li>Connect to an external API</li>
<li>Start responding to HTTP requests</li>
</ol>
</li>
<li>solution

<ul>
<li>Promise whens and thens</li>
<li>async.auto

<ul>
<li>example <br/>
  async.auto({

<pre><code>readConfigFile:readConfigFile,
connectToDB:
['readConfigFile',connectToDB],
connectToCache:['readConfigFile',connectToCache],
cacheObjects:
['connectToDB','connectToCache',cacheObjects],
connectToAPI: connectToAPI,
</code></pre>

<p>  acceptHTTPReqs:['connectToDB','connectToCache','connectToAPI',
  acceptHTTPReqs]
  });</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>alternative

<ul>
<li><p><a href="https://github.com/creationix/step">TimCaswell’s Step</a></p>

<blockquote><p>Stepis much lighter
  than Async.js,with an API consisting of a
  single function: Step. Step takes alist of
  functions, e.g.
  Step(task1, task2, task3);</p></blockquote></li>
<li><p><a href="https://github.com/coolaj86/futures">Futures</a></p></li>
<li><a href="https://github.com/nakamura-to/nue">nue</a></li>
<li><a href="https://github.com/isaacs/slide-flow-control">slide</a>

<h2>Multi-threading with Workers</h2></li>
<li><p>Web Workers</p>

<blockquote><p>WebWorkers are part of the living standard
  widely known as HTML5.To create one,you
  call the global Worker constructor with the
  URL of a script:</p></blockquote>

<pre><code>  var worker = new Worker('kimptoc.js');
  worker.addEventListener('error',function(){
  console.log('Ch
  failed to load.');
  });   
</code></pre>

<ul>
<li>Talking to Web Workers

<ul>
<li>self.postMessage</li>
</ul>
</li>
<li>Restrictions on Web Workers

<ul>
<li>Performing physics calculations for
games with CoffeePhysics.</li>
<li>Decoding video as it streams in with
the Broad way implementation of the
H.264 codec.</li>
<li>Encrypting communications with the
Stanford JavaScript Crypto Library</li>
<li>updatethe page.</li>
<li>can’tseethe global window object</li>
</ul>
</li>
<li>importScripts will(synchronously) load and run the given script(s)</li>
<li>browsers support WebWorkers

<ul>
<li>Chrome</li>
<li>FF</li>
<li>Safari</li>
</ul>
</li>
</ul>
</li>
<li><p>Node Workers with cluster</p>

<ul>
<li>Typically,cluster is used to spin up one
process per CPU core for optimal perform-ance(though whethe reach process will actu-allygetits own core is entirely upto the un-derlying OS):</li>
</ul>


<p>  var cluster = require('cluster');
  if(cluster.isMaster){
  // spin up workers
  var coreCount=require('os').cpus().length;
  for(vari=0;i&lt;coreCount;i++){
  cluster.fork();
  }
  // bind death event
  cluster.on('death',func-tion(worker){
  console.log('Worker
  '+worker.pid+' has died');
  });
  }else{
  // die immediately
  process.exit();
  }</p>

<ul>
<li>child_process.fork</li>
<li>Talking to Node Workers</li>
</ul>


<p>  var  cluster = require('cluster');
  if(cluster.isMaster){
  // spin up workers
  var coreCount=require('os').cpus().length;
  for(var i=0;i&lt;coreCount;i++){
  var worker=cluster.fork();
  worker.send('Hello, Worker!',2);
  worker.on('message',function(message){
  if(message._queryId)return;
  console.log(message);
  });
  }
  }else{
  process.send('Hello, mainprocess!');
  process.on('message',function(message){
  console.log(message);
  });
  }</p>

<ul>
<li>Restrictions on Node Workers

<blockquote><p>For the most part,cluster obeys the same
rules as WebWorkers:There’s a master,and
there are Workers;they communicate via
events with attached strings orserializable objects. However, while Workers are obviously second-class citizens in the  browser, Node’s Workers possess all the rights and privileges of the master except</p></blockquote>

<pre><code>1. The ability to shut down the application,
2. The ability to spawn more Workers,
and
3. The ability to communicate with each other.
</code></pre>

<ul>
<li><a href="https://github.com/fent/clusterhub">Clusterhub</a>

<blockquote><p>Clusterhubprovides a hub object to each
process that acts as an inter-process
EventEmitter and EventVat store</p></blockquote>

<ul>
<li><a href="https://github.com/hij1nx/EventVat">EventVat</a></li>
<li>  // master
  varhub=require('clusterhub');
  hub.set('hitCount',0);
  // Workers
  varhub=require('clusterhub');
  functiononRequest(){
  hub.in-cr('hitCount',func-tion(hitCount){
  // ...
  });
  }</li>
</ul>
</li>
<li>Temporary threads

<ul>
<li>single block of synchronous code to be run in a  separate  thread</li>
<li>create  and manage a pool of  Web Workers</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>Async Problems and Solutions</h2>

<h3>Problem: Where’d this go?</h3>

<p>It’s  a  rite  of  passage  for  JavaScripters:  You pass  a  callback.  You  use  this in  that  callback,not  giving  the matter  much  thought.
You spend  the  next  several  hours  trying  to figure out why your code is broken and cursing the day you were born. Or, at least, you join  one of the thousands who’ve  posted  examples like this to Stack Overflow:</p>

<pre><code>    // each button has data indicating an "action" to take 
    $('button').click (function (){ 
    $(this).after ('&lt;a href="#" 
    id="confirm"&gt;Confirm&lt;/a&gt;'); 
    $('#confirm').click (function (){ 

    var action = $(this).data ('action'); 
         // why is action undefined???
    });
    });
</code></pre>

<p>jQuery bears some responsibility for the confusion.  Devs  who  are  unaware  of the call
and apply methods that can warp it to anything  a function’s caller desires expect  this to scope like an ordinary variable,  albeit one mysteriously  set  in  their  event  handlers  via dark magicks. But the problem also arises in ordinary setTimeouts:</p>

<pre><code>    var account = { 
    balance :500, 
    showBalance:function (){console.log (this.balance); } 
    }; 
    account.showBalance()
    setTimeout(account.showBalance, 0);// undefined 
</code></pre>

<p>account.showBalance() calls  the  method  in  the account context,  but when account.showBalance is  passed  to a  function, the original context is lost.</p>

<ul>
<li><p>Solution 1: Capture this</p>

<p>  The  most  common  solution to  this  problem
  is to simply store the value of this that you
  want  in  a  separate variable.  Traditionally,  a
  name like  selfis used, but I prefer a clearer
  identifier:</p>

<pre><code>  $('button').click (function () { 
    var button = this; 
    $(button).after ('&lt;a href="#" 
  id="confirm"&gt;Confirm&lt;/a&gt;')
  $('#confirm').click (function (){ 
   var action = $(button).data ('action'); 
      // works! 
     }); 
   }); 
</code></pre>

<p>  This works for our  setTimeout example as
  well: Just change showBalanceto</p>

<pre><code>  showBalance: function () { console.log (account.balance); } 
</code></pre></li>
<li><p>Solution 2:
Bind callbacks to this JavaScripters have long known that a function can be made impervious to the dark magicks of call and apply by wrapping them in another function.Utility libraries like Underscore.js include a bind method for just such a purpose:</p>

<pre><code>   $('button').click (function () { 
     $(this).after ('&lt;a href="#" 
   id="confirm"&gt;Confirm&lt;/a&gt;'); 
     $('#confirm').click (_ .bind (function (){ 

   var action = $(this).data ('action'); 
      // works! 
     },this)); 
   }); 
</code></pre>

<p>What we’ve done here is forced the inner callback to have the same value of this as the outer one. This is such a common pattern that CoffeeScript makes it as easy as declaring the bound function with  => instead of  ->.  In newer JS runtimes (cutting-edge browsers and Node),the bind method is part of the function prototype itself,  so we could write:</p>

<pre><code>  $('#confirm').click ((function () { 
     ... 
   }).bind (this)); 
</code></pre></li>
</ul>


<p>Binding is widely used but slightly controversial.  It’s generally less efficient than capturing this, and has a tendency to complicate stack traces. See Patrick Mueller’s blog post “<a href="http://pmuellr.blogspot.com/2010/06/bind-considered-harmful.html">bind() considered harmful.</a>”  Perhaps more importantly,  when some callbacks are bound  and  others  aren’t,  it  tends  to  exacerbate  confusion about what  this is at a particular line of code.</p>

<ul>
<li><p>Solution 3: Work around this This solution only applies to jQuery, as most libraries are content to allow this in callbacks to take its default value, the root object (window in browsers, global in Node).
jQuery is not, and some prominent JavaScript developers (including Jeremy Ashkenas, creator of CoffeeScript and Backbone.js) have called that a mistake. Although most jQuery coders use this to get the DOM element that an event was fired from, you can use the less ambiguous e.currentTarget instead (where e is the event object that jQuery passes as the first argument to the handler):</p>

<pre><code>   $('button').click (function (e) { 
   $(e.currentTarget).after ('&lt;a 
  href="#" 
  id="confirm"&gt;Confirm&lt;/a&gt;'); 
    $('#confirm').click (function (){ 

   var action = $(e.currentTarget).data ('action'); 
      // works! 
     }); 
   }); 
</code></pre>

<p>Of course, e is just as prone to overuse as this, so consider using a distinguishing identifier like buttonEvent instead.</p></li>
</ul>


<h3>Problem: Retrying async tasks</h3>

<p>Often, we’ll want to attempt an async task n times before declaring failure, particularly when the task involves connecting to a remote server.  The basics of this problem are obvious:
1.  We need to store the number of failed attempts
2.  When an attempt fails, we need to increment the number of failed attempts and check whether it exceeds the maximum This translates into a lot of boilerplate code that we don’t want to repeat every time we run into this scenario, e.g.</p>

<pre><code>    var callback, failedAttempts = 0, asyncTask (callback = function (err) { 
      if (err) { 
         failedAttempts++; 

     if (failedAttempts &gt;=maxAttempts) { 
           failCallback(err); 
         }else { 
          asyncTask (callback); 
         }; 
       }else { 

     successCallback (Array.prototype .slice.call (arguments, 1)); 
       }; 
     }); 
How can we make this simple? 
</code></pre>

<ul>
<li>Solution 1:
Callback-style Assuming that we’re using Node-style callbacks, we can translate our boilerplate above into a reusable utility function:

<pre><code>   function attemptAndRetry (asyncTask, maxAttempts, callback) { 
    asyncTask (function (err) { 
      if (err) { 
        if (maxAttempts &lt;= 1) { 
          callback (err); 
        }else { 

   attemptAndTry (asyncTask,maxAttempts 1,callback); 
        }; 
      }else { 

   callback (null,Array.prototype .slice.call (arguments 
    }; 
     }); 
   } 
</code></pre></li>
</ul>


<p>Notice that we’re using quasi-recursion here.
There’s no risk of exceeding the stack limit, as long as asyncTask’s callback runs from the event queue.</p>

<p>This is the most direct solution, but there are a couple of things I don’t like about it.  For one, calling the function is a tad awkward:</p>

<pre><code>    attemptAndRetry (function (callback) { 
      fs.readFile ('locked.txt', 'utf8',callback); 
     },3,function (err,result) { 
      // ... 
     }); 
</code></pre>

<p>Another problem is that we don’t get finegrained control over the process.         For instance, what if we want to log the error on each failed attempt?</p>

<ul>
<li>Solution 2:
PubSub-style As is so often the case in JavaScript, the best solution is an EventEmitter.  It allows us to expose an extremely versatile API from a simple function. To wit:

<pre><code>  var EventEmitter = require ('events').EventEmitter; 
  function attempt (asyncTask) { 
    var emitter = new EventEmitter (),results; 
    emitter.failedAttempts= 0; 
    function retry = function (){ 
  asyncTask (function (err) { 
        if (err) { 
          emitter.failedAttempts++; 

   emitter.emit ('failure',err,retry); 
        }else { 

   results = Array.prototype .slice.call (arguments, 1); 

   emitter.emit ('success',results); 
        } 
       }); 
     } 
    process .nextTick (retry); // ensure asynchronicity return emitter; 
   } 
</code></pre></li>
</ul>


<p>This may be a little more complicated than our earlier definition, but it makes things extremely easy for the caller:</p>

<pre><code>    var reading = attempt (function (callback) { 
      fs.readFile ('locked.txt', 'utf8',callback); 
     }); 
    reading.on ('failure',function (err,retry) { 
      console.error (err); 
      if (reading.failedAttempts&lt; 3)retry (); 
     }); 
    reading.on ('success',function (contents) { 

     // ... 
     }); 
</code></pre>

<p>Now we have cleanly exposed state and precise control over when we retry our function.
Plus, because we can attach multiple handlers for the same event, it’s easy to view the process state from multiple perspectives. We could, for example, map the task onto a Promise for easy monitoring:</p>

<pre><code>    var deferred = new $.Deferred (); 
    reading.on ('failure',function (err,retry) { 
      if (reading.failedAttempts &gt;= 3)deferred.reject (err); 
     }); 
    reading.on ('success',deferred.resolve) 
</code></pre>

<p> ###Problem: Testing async code In languages like Java and Ruby, test cases can just be lists of assertions. Unfortunately, that won’t cut it when testing async JavaScript code, because the test runner has no way of knowing when the test case is complete. It’s important to use a JavaScript testing framework that can handle async test cases and produce meaningful output despite the unpredictable order of assertions.</p>

<ul>
<li>Solution: Use Mocha The successor to Expresso, Mocha is a onesize-fits-all testing framework for both the browser and Node.  While async testing was something of a pain in older testing frameworks like QUnit (requiring async test cases to manually start and stop the runner), Mocha makes it  “just work.”  Here’s an example using Mocha’s T        -style interface (which I prefer for its simplicity over the default Bstyle interface):

<pre><code>  var assert = require ('assert'); 
  suite('gamification',function (){ 
    setup(gamify); 
    test ('gamify resets points',function (){ 
      assert.equal (points, 0); 
     }); 
    test ('player points are loaded on login',function (done) { 
      assert.equal (points, 0); 

   login (mock .username,mock .password,function (err,success) { 
        if (err)throw err; 
        assert.ok (success); 

   assert.equal (points,mock .points); 
     done (); 
       }); 
     }); 
   }); 
</code></pre></li>
</ul>


<p>Assume the assertions all pass.     When this code is run, via the command mocha  -u tdd test.js, the test runner will report the first test case’s success as soon as it returns, and will report the second test case’s success as soon as it calls done.         But wait—how did it know to wait for done to be called in the second case?</p>

<p>The magic here is in a JavaScript feature called arity.  The arity of a function is the number of declared arguments it takes. That number is exposed as the lengthproperty:</p>

<pre><code>(function () 
 { ... }).length;  // 0 (function (done) { ... }).length; // 
</code></pre>

<p>1 Using this to distinguish synchronous functions from async ones is a clever hack, though it comes with a caveat: If you accidentally declare a synchronous test case with an argument, e.g.</p>

<pre><code>    test ('bedard', function (done) { 
      assert.ok (true); 
     }); 
</code></pre>

<p>you’ll get the error output x 1 of 1 tests failed: 1)  bedard: Error: timeout of 2000ms exceeded Usually, declaring functions without unnecessary arguments is good style.  In Mocha, it’s a matter of life or death.</p>

<h3>Problem:</h3>

<p>Aggregating events With the rise of evented models, it’s become easy to oversaturate an application with events, slowing it to a crawl. For instance, in a game, we might represent each of thousands of characters in a level with a Backbone model and perform game logic in response to any changes in those models.  But when the player throws a grenade that blows up 100 monsters at once, we don’t want to perform the same logic 100 times.  How can we avoid this?</p>

<ul>
<li>Solution 1:
Silence the change events Backbone gives us a special flag that we can use to change models without them emitting a  'change'event:

<pre><code>  monsters.each (function (damage) { 
    this.set({life:this.get ('life')age}, {silent:true}); 
   }); 
</code></pre></li>
</ul>


<p>Used carefully, this is the most efficient solution to our problem. But it’ll only work if we have absolute knowledge about what’s supposed to happen when each model we’re silently modifying changes.</p>

<p>Silencing events is like a scalpel. With steady hands and precise planning, it can be an invaluable tool;  otherwise, it’s just going to make a mess.</p>

<ul>
<li>Solution 2:
Use a simple timeout Remember that even a 0ms delay will ensure that a function runs after all synchronous code.  We can use that to our advantage by having a checkGameState function runs just once after all of the individual monster models have been updated:

<pre><code>  var checkGameStateTimeout; 
   function checkGameState (){ 
     // if no monster allies remain, you lose var isTheGameLost= monsters .filter (function (){ 
      return this.get ('ally'); 
     }).length=== 0; 
     // and so on... 
  } 
  var monsters = new Backbone.Collection; 
  monsters .on ('change',function (){ 
    clearTimeout (checkGameStateTimeout); 
    checkGameStateTimeout = setTimeout( 
  GameState, 0); 
   }); 
</code></pre></li>
</ul>


<p>Now no matter how many monsters are changed simultaneously, checkGameState will fire just once in response.</p>

<ul>
<li>Solution 3:
Throttling/Debouncing We’ve looked at one solution that operates from the part of the app that updates the models and another that works from the models’ end.  But the most elegant approach is usually to act on the particular function that we want to prevent from being called too often.  In general terms, that means we want to limit checkGameState to running once every n milliseconds. There are two basic approaches to this:</li>
<li>Throttling, where additional calls to the function are ignored if its last run was less than n ms ago, and</li>
<li>Debouncing, where any call to the function is delayed until n ms have elapsed since the last call Usually, you want throttling, because debouncing adds some latency to every function call.    Plus, debouncing means that a function will never be called if it’s called too often! (Sometimes debouncing is implemented with a maximum delay to avoid this.)
However, debouncing is preferable in scenarios where you want to wait until an input source is idle, such as rendering a preview or running a validation only after the user has momentarily stopped typing.</li>
</ul>


<p>Both throttling and debouncing are easy to implement by creating a meta-function that returns a wrapped version of the original function.Here are two simple implementations:</p>

<pre><code>    function throttle (func, minDelay) { 
      var lastHitDate = 0; 
      return function (){ 
        var now = new Date (); 

     if (now lastHitDate &gt;=minDelay) { 
          lastHitDate = now; 

     return func.apply (this,arguments); 
        }; 
    }; 
     } 

    function debounce (func, delay) { 
      var timeout; 
      return function (){ 
        var args = arguments; 
        clearTimeout (timeout); 
        timeout = setTimeout(function (){ 
          func.apply (this,args); 
         },delay); 
       }; 
     } 

(If you’re using Underscore.js—and you should!—you can just use _.throttle and _.debounce.) 
</code></pre>

<p>With these utility functions, we can either overwrite checkGameState entirely or just use the wrapped version from our change events.  For our purposes, debounce with a delay of 0 is most appropriate, since throttle with a short delay would allow checkGameState to run more within a block of synchronous code. debouncewith a delay of 0 is effectively equivalent to the setTimeoutwe used in solution 2:</p>

<pre><code>    var debouncedCheckGameState = debounce (checkGameState, 0); 
    monsters .on ('change',function (){ 
      debouncedCheckGameState (); 
     }); 
</code></pre>

<p>Note that it’s important to use the same throttled/debounced instance of a function from every source that we want to limit calls from. Calling (debounce (checkGameState, 0))();
would just be an overly complicated way of calling setTimeout(checkGameState, 0);</p>

<p>because calling debounce(checkGameState, 0) again would just create a separate timeout.</p>

<h3>Problem:</h3>

<p>Handling requests Quick question:
You’re a web server. You receive a request. What do you do?</p>

<p>Most likely, lots of unrelated things. At a minimum, you look at the requested route and map it to a file that you send in response. But you also probably log the request, check whether the requester is properly authenticated, and fetch some data. Maybe you cache the response in memory, too. Many of these pieces of functionality will be the same for some or all routes. How do you avoid duplication?</p>

<ul>
<li>Solution:
The middleware pattern In the Node.js Connect framework, each middleware function takes a request object (req), a response object (res), and a next callback. Every time a new request comes in, it’s passed to the first middleware. The middleware has three (good) options:</li>
<li>Handle the request itself by sending a response and returning without calling next.</li>
<li>Call nextwith no arguments.</li>
<li><p>Call nextwith an error argument. The next callback Connect generates either passes the request on to the next middleware on the stack, or to an error handler. And that’s basically all Connect does. This simple pattern (the core implementation is less than 200 lines) has proven so successful that just about every Node server framework has been built on top of Connect, most notably Express.js. Consider using the middleware pattern in other contexts where an action needs to be handled in several discrete steps. The only difference between a middleware stack and an ordinary callback stack (like we saw in Chapter 2) is that each function on the stack receives a next function that allows it to declare that it’s finished, making an async series of actions possible. Here’s a minimal implementation for comparison’s sake:</p>

<pre><code>// callback stack function trigger (){ 
  handlers.forEach(function (handler) { 
    handler (); 
   }); 
 } 
// middleware stack function trigger (){ 
  invoke (0); 
 } 
function invoke (idx) { 
  if (handlers.length&lt;= idx) { 
    return; 
   }else { 
    handlers [idx](function (err) { 
      if (err)throw err; 

 if (handlers.length &gt; idx + 1)invoke (idx + 1); 
   }; 
} 
</code></pre></li>
</ul>


<p>Perceptive readers may be reminded of async.series from Chapter 4. Connecting functions this way is an extremely common pattern. Feel free to reinvent the wheel, but be aware that the wheel is already available under the MIT License.</p>

<h3>Problem:Ajax spaghetti</h3>

<p>Consider this an integrative exercise. How do we turn highly nested code like this into something clearer, better-organized, less repetitive, and easier to modify if we decide to change our application’s behavior?</p>

<pre><code>    $(function () { 
      $('#menu').on ('click', 'a',function clickHandler (){ 
        // we put a spinner on the selected menu item var $clickedLink= $(this).spin(); 
        // we disable the menu until our Ajax call returns 
        $('#menu').off ('click', 'li &gt; 
    a'); 

     $.get ('/content/'+ $clickedLink. success:function successHandler(response) { 
            $clickedLink.unspin (); 
            $('#menu').on ('click', 'li &gt; 
    a',clickHandler); 
            // we fade the content out... 

     $('#content').fadeOut(function (){ 
              // ...then we fade it in with the Ajax markup 

     $('#content').html (response).fadeIn(); 
            }); 
          }, error:function (){ 
            // we make one retry in case the error is just a fluke 
    $.get ('/content/' + $clickedLink.index (),{ 
              success:successHandler, error:function (){ 
                $clickedLink.unspin (); 
                $('#menu').on ('click', 'li &gt; 
    a',clickHandler); 
               modal ('Error retrieving content from the server.'); 
              } 
            }); 
          } 
        }); 
        return false; // prevent default click behavior 
      }); 
    }); 
</code></pre>

<ul>
<li>Solution:
Distribute, distribute, distribute The big problem with the code above is that it’s way too centralized. Everything that happens in response to a menu click goes in the click handler, and everything that happens in response to the Ajax request goes in the Ajax response handler. We need to spread things out in a way that makes sense. There are plenty of ways we could do that here—using custom jQuery events, for example—but the approach I’d recommend is using an evented model to represent the menu. The model will encapsulate the state that we need to capture from the various async events, and the abstraction will make it easy for us to change our event flow in the future. Let’s start by asking, “What state do we need to store?” I can think of three things:</li>
<li>Whether our menu is in its  “ready,”
clickable state, or in the     “unready”<br/>
state with a spinner over the active link.</li>
<li>Which link is currently active (in the process of having associated content loaded), if any.</li>
<li>How many attempts we’ve made so far to request content from the server for the active link. The first two sound like they should be associated with the menu. So that gives us our menu model:

<pre><code> window.menu = new Backbone.Model ({ 
   ready:false, activeLinkIndex:-1 
  }); 
</code></pre>

<p>Why does our menu start out with ready:
false? Because the menu element may not exist yet in the document. We want readyto correspond to the click handler being attached. We also want to ensure that there is no active link when the menu becomes ready:</p>

<pre><code>  menu .on ('change:ready', function (ready) { 
  if (ready) { 
  $('#menu').on ('click', 'li &gt; 
  a',menu .clickHandler); 
  menu .set('activeLinkIndex',-1); 
  }else { 
  $('#menu').off ('click', 'li &gt; 
  a'); 
  } 
  }); 
</code></pre></li>
</ul>


<p>Notice the reference to menu.clickHandler. For convenient namespacing, we’ll go ahead and attach all of our menu-related event handlers to the menu model:</p>

<pre><code>    menu .clickHandler = function () { 
      menu .set({ready:false,activeLinkIndex:$(this).index ()}); 
      return false; 
     } 
</code></pre>

<p>Declaring the menu ready is the only thing that has to wait for the DOM. So our jQuery callback, which originally wrapped around everything, is just a one-liner:</p>

<pre><code>    $(function () { menu .set({ready: 
    true}); 
</code></pre>

<p>(Note that it’s important for this line to come after menu.clickHandler is defined, because the callback will run synchronously if the document is already ready.)</p>

<p>The click handler modifies the menu’s activeLinkIndex, so let’s respond to that by fetching the appropriate content and adding the Ajax spinner to the correct menu item:</p>

<pre><code>    menu .on ('change:activeLinkIndex', function (activeLinkIndex) { 
      $('#menu').children ().unspin (); 
         .eq (activeLinkIndex).spin(); 
      menu .fetchSelectedContent(); 
     }); 
</code></pre>

<p>If activeLinkIndex is changed to  -1 (indicating that no link is active), the eq(activeLinkIndex) selector will match no elements, so no Ajax spinner will appear. And the first line of our fetchSelectedContentwill simply return:</p>

<pre><code>    menu .fetchSelectedContent = function () { 
      if (menu .get ('activeLinkIndex')=== -1)return; 
      $.ajax ({ 

     url: 
    '/content/'+menu .get ('activeLinkIndex'), tryCount:0 
       }) 
       .done ($('#content').fadeHtml) 
       .done (function (){menu .set({ready:true}); }) 
       .failure(function (){ 
        this.tryCount++; 
        if (this.tryCount &gt;= 2) { 
          modal ('Error retrieving content from the server.'); 
    }else { 
          $.ajax (this); 
         }; 
       });); 
     } 
</code></pre>

<p>This is our most complex function, but every line serves a clear purpose. When the Ajax call succeeds: <br/>
1. The content element’s fadeHtml method is called with the data retrieved from the server. fadeHtml is a simple plugin that we’ll define shortly.<br/>
2. The menu is restored to its ready state. Recall that this will also reset activeLinkIndexto 1. When the Ajax call fails:<br/>
1. this in a jQuery Ajax callback points to the jqXHR object that, among other things, stores all of the settings passed in to  $.ajax. We use that to store our tryCount.<br/>
2. Because this also contains our url property, we can simply write $.ajax(this) to reattempt the Ajax call. This technique was popularized by a blog post entitled  “Defensive Ajax and Ajax retries in jQuery.”</p>

<p>If we felt like the fetchSelectedContent method was too large, we could move the failure handler out of it. That’s the great thing about evented code:
As long as state is stored rationally, you have unlimited flexibility. Now the only gap left to fill in is to define fadeHtml:</p>

<pre><code>     $.fn.fadeHtml = function (markup) { 
      return this.fadeOut(function (){ 
        $(this).html (markup).fadeIn(); 
       }); 
     }; 
</code></pre>

<p>And that’s it! We have a little more code than we started with, but it’s many times easier to work with.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to build a framework]]></title>
    <link href="http://zjhiphop.github.com/blog/2012/06/03/how-to-build-a-framework/"/>
    <updated>2012-06-03T15:40:00+08:00</updated>
    <id>http://zjhiphop.github.com/blog/2012/06/03/how-to-build-a-framework</id>
    <content type="html"><![CDATA[<p>If let u to build a javascript framework,how will you do?<br/>
对比几个比较流行的jQuery等框架，不难发现，有以下几个基础部分：<br/>
* 浏览器的兼容性检测<br/>
* 干净，可重用的API设计<br/>
* 有统一的基准和性能<br/>
* 编写有好的轻量的javascript<br/>
* 使用Github</p>

<h2>为了便于合作，我们必须订立好项目的目标和开发的风格,以下是一种尝试：</h2>

<blockquote><p>复杂性Verbose: 变量和方法名必须是有意义的，易懂和易理解<br/>
移植性Portable: 浏览器和控制台<br/>
显式的Explicit: 代码应该是可以快速理解的<br/>
注释Comments: 注释需要简洁明了的。TODO 和 FIXME 可以详细一点.<br/>
简单Simple:   保持代码简单<br/>
缩进Indentation: 两个空格<br/>
分号Semicolons:  添加分号以便人们可以方便压缩<br/>
质量Quality: JsLint和读者留言!<br/>
测试Testing: 在浏览器和控制台中都要测试<br/>
版本控制Versioning: 使用GitHub</p></blockquote>

<h2>高级框架结构</h2>

<ul>
<li>prototype</li>
<li>namespace</li>
<li>traits</li>
<li>CommonJS</li>
</ul>


<h3>Helper Methods</h3>

<p>为什么?</p>

<blockquote><p>reduce the effort required to call commonly used functions<br/>
how?<br/>
should be succinct but clear</p></blockquote>

<h3>初始化</h3>

<ul>
<li>version</li>
<li>metadata</li>
</ul>


<h3>模块和插件</h3>

<ul>
<li>define your own global namespace,like jQuery,Mooltools etc.</li>
</ul>


<h3>选择测试框架</h3>

<ul>
<li>riot.js</li>
<li>jasmine</li>
</ul>


<h2>面向对象的javascript</h2>

<p>为什么？<br/>
1. 便于管理自己的代码<br/>
2. 对于Java或Ruby程序员来说很习惯这种方式</p>

<h3>原型vs类继承</h3>

<h4>原型的优点：</h4>

<ol>
<li>it’s useful to abstract it</li>
<li>offer extra features beyond what JavaScript has as standard</li>
</ol>


<h4>类继承</h4>

<p>优点：
1. keeps code simpler
2. it easer for people to navigate your code.</p>

<p>缺点：<br/>
1. 创建对象需要用一个包装器，如：Class.create</p>

<h3>创建自己的继承方法：</h3>

<ol>
<li>The ability to extend classes with new methods by copying them</li>
<li>Class creation: use of apply and prototype.constructor to run the constructors</li>
<li>The ability to determine if a parent class is being passed for inheritance</li>
<li>Mixins</li>
</ol>


<h3>继承：</h3>

<pre><code>for (var property in source )
    destination [property ] = source [property ];
</code></pre>

<h3>创建类：</h3>

<pre><code>// This would be defined in our "oo" namespace
create : function (methods ) {
    var klass = function () { this.initialize .apply (this, arguments ); };
    // Copy the passed in methods
    extend (klass .prototype , methods );
    // Set the constructor
    klass .prototype .constructor = klass ;
    // If there's no initialize method, set an empty one
    if (!klass .prototype .initialize )
    klass .prototype .initialize = function (){};
    return klass ;
}
</code></pre>

<h3>更深层次的类：</h3>

<p>initialize 方法是我们的构造函数。使用Class.create的方法来创建新类。</p>

<h3>语法糖</h3>

<p>Extend === Mixin ?</p>

<p>Mixin是通过简单的规则将对象的属性进行组合：    Methods should be included from the specified classes    The initialize method should not be overwritten    Multiple includes should be possible</p>

<pre><code>var MixinUser = Root.Class ({
    include : User,
    initialize : function (log) {
        this.log = log;
    }
});
</code></pre>

<p>Super</p>

<pre><code>var SuperUser = Root.Class(User, {
    initialize : function () {
        this.$super('initialize' , arguments );
    },
    toString : function () {
        return "SuperUser: " + this.$super ('toString' );
    }
});
</code></pre>

<h2>函数式编程：</h2>

<p>why?<br/>
1. use ideas from functional programming to simplify common programming tasks<br/>
2. we need define our own method like iterator to cause the browser support is inconsistent<br/>
what?   Describing problems rather than focusing on the mechanics of their solution    Treating functions as first class citizens, and manipulating them like variables   Avoiding state and mutable data</p>

<h3>迭代器Iterators</h3>

<blockquote><p>Enumerable uses each to create lots of other methods that are inspired by functional languages. Any collection-style object can mixin Enumerable to get all those methods for free.</p></blockquote>

<p>Underscore's each</p>

<pre><code>// The cornerstone, an each implementation.
// Handles objects implementing forEach, arrays, and raw objects.
// Delegates to JavaScript 1.6's native forEach if available.
var each = _.forEach = function (obj, iterator , context ) {
try {
if (nativeForEach &amp;&amp; obj.forEach === nativeForEach ) {
    obj.forEach (iterator , context );
} else if (_.isNumber (obj.length )) {
    for (var i = 0, l = obj.length ; i &lt; l; i++) iterator .call(context , obj[i], i, obj);
} else {
    for (var key in obj) {
        if (hasOwnProperty .call(obj, key)) iterator .call(context , obj[key], key, obj);
    }
}
} catch (e) {
    if (e != breaker ) throw e;
}
    return obj;
};
</code></pre>

<h3>基准Benchmarks</h3>

<blockquote><p>The native method performs very well than defined by yourself</p></blockquote>

<h3>API设计</h3>

<p>why?<br/>
* easy to use<br/>
* avoid conflict with third party libs <br/>
* safely namespacing</p>

<h3>为each定义更多函数方法</h3>

<p>Filter<br/>
1. Check if there’s a native filter method and use it if possible<br/>
2. Else use Root.enumerable.each<br/>
3. Filter objects into multi-dimensional arrays if required<br/>
Detect</p>

<blockquote><p>Detect simply uses each with the user-supplied callback, until a truthy value is returned. Then it throws a Break.<br/>
Chaining<br/>
Chained functions are possible when each function returns an object that can be used to call the next one.<br/>
1. Store temporary values<br/>
2. Runs appropriate methods from Root.enumerable by mapping the temporary value into the first argument<br/>
3. After running the method, return this so the chain can continue</p></blockquote>

<h3>实现：</h3>

<pre><code>// store temporary values in this.results
Root.enumerable .Chainer = Root.Class ({
    initialize : function (values ) {
    this.results = values ;
    },
    values : function () {
    return this.results ;
    }
});
// Map selected methods by wrapping them in a closure that returns this each time
Root.enumerable .each(['map' , 'detect' , 'filter' ], function (methodName ) {
    var method = Root.enumerable [methodName ];
    Root.enumerable .Chainer .prototype [methodName ] = function () {
        var args = Array .prototype .slice .call(arguments );
        args.unshift (this.results );
        this.results = method .apply (this, args);
        return this;
    }
});
</code></pre>

<h2>选择器和引擎(Selector and Selector Engines)</h2>

<ol>
<li>XPath</li>
<li>CSS</li>
</ol>


<h3>浏览器支持</h3>

<p>Sizzle的做法：</p>

<blockquote><p>It creates a fake element to probe browser behaviour. Supporting browsers is a black art beyond the patience of most well-meaning JavaScript hackers.</p>

<pre><code>// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function (){
    // We're going to inject a fake input element with a specified name
    var form = document .createElement ("div" ),
    id = "script" + (new Date()).getTime ();
    form.innerHTML = "&lt;a name='" + id + "'/&gt;" ;
    // Inject it into the root element, check its status, and remove it quickly
    var root = document .documentElement ;
    root.insertBefore ( form, root.firstChild );
</code></pre></blockquote>

<h3>性能</h3>

<ol>
<li>缓存
2，使用native的方法，如：querySelectorAll</li>
</ol>


<h3>tools</h3>

<ol>
<li><a href="http://mootools.net/slickspeed/">slickspeed</a></li>
</ol>


<h3>选择器引擎</h3>

<ol>
<li><a href="http://jamesdonaghue.com/static/peppy/docs/">Peppy</a></li>
<li><a href="http://digitarald.de/journal/89737433/rolling-out-sly-the-javascript-selector-engine/">sly</a></li>
<li><a href="http://sizzlejs.com/">Sizzle</a></li>
</ol>


<h3>API 设计</h3>

<ol>
<li>使用函数包装器，链式调用</li>
<li>返回并扩展选择的元素，如prototype使用$()使用getElementById.$$()使用CSS或XPath</li>
</ol>


<h3>目标</h3>

<ol>
<li>CSS selectors only (XPath could be a future upgrade or plugin)</li>
<li>Limited pseudo-selectors. Implementing one or two would be nice just to establish the API for them</li>
<li>Defer to native methods as quickly as possible</li>
<li>Cache for performance</li>
<li>Expose the parsing results like Sly does</li>
<li>Reuse the wisdom of existing selector engines for patching browser nightmares</li>
</ol>


<h3>CSS 选择器</h3>

<blockquote><p><a href="http://www.w3.org/TR/CSS2/selector.html">CSS2 selectors</a>,<a href="http://www.w3.org/TR/CSS21/grammar.html">CSS2 grammer</a><br/>
1. E – Matches any element named E<br/>
2. E F – Matches any element F that descends from E<br/>
3. .class – Matches any element with the class class<br/>
4. E.class – Matches any element named E with the class class<br/>
5. #id – Matches any element with the id id<br/>
6. E#id – Matches any element named E with the id id</p></blockquote>

<h3>CSS的解析规则</h3>

<ol>
<li>ID Rules</li>
<li>Class Rules</li>
<li>Tag Rules</li>
<li><p>Universal Rules<br/>
<a href="https://developer.mozilla.org/en/Writing_Efficient_CSS">Writing_Efficient_CSS</a></p></li>
<li><p>Avoid universal rules</p></li>
<li>Don’t qualify ID rules with tag names or classes

<blockquote><p>BAD
 button#backButton {…}<br/>
 BAD<br/>
 .menu-left#newMenuIcon {…}<br/>
 GOOD<br/>
 #backButton {…}<br/>
 GOOD<br/>
 #newMenuIcon {…}</p></blockquote></li>
<li>Don’t qualify class rules with tag names

<blockquote><p>BAD<br/>
 treecell.indented {…}<br/>
 GOOD<br/>
 .treecell-indented {…}<br/>
 BEST<br/>
 .hierarchy-deep {…}</p></blockquote></li>
<li>Use the most specific category possible

<blockquote><p>BAD<br/>
 treecell.indented {…}<br/>
 GOOD<br/>
 .treecell-indented {…}<br/>
 BEST<br/>
 .hierarchy-deep {…}</p></blockquote></li>
<li>Avoid the descendant selector

<blockquote><p>BAD<br/>
 treehead treerow treecell {…}<br/>
 BETTER, BUT STILL BAD (see next guideline)  <br/>
 treehead > treerow > treecell {…}</p></blockquote></li>
<li>Tag category rules should never contain a child selector

<blockquote><p>BAD<br/>
 treehead > treerow > treecell {…}<br/>
 GOOD<br/>
 .treecell-header {…}</p></blockquote></li>
<li>Question all usages of the child selector

<blockquote><p>BAD<br/>
 treeitem[IsImapServer="true"] > treerow > .tree-folderpane-icon {…}<br/>
 GOOD<br/>
 .tree-folderpane-icon[IsImapServer="true"] {…}</p></blockquote></li>
<li>Rely on inheritance

<blockquote><p>BAD<br/>
 #bookmarkMenuItem > .menu-left { list-style-image: url(blah) }<br/>
 GOOD<br/>
 #bookmarkMenuItem { list-style-image: url(blah) }</p></blockquote></li>
<li>Use -moz-image-region for ff!</li>
<li>Use <a href="http://updates.html5rocks.com/2012/03/A-New-Experimental-Feature-style-scoped">scoped stylesheets</a> to reduce inefficiency of universal rules and child selectors</li>
</ol>


<h3>分词器(Tokenizer)</h3>

<h3>给你一个selector，我们需要做：</h3>

<ol>
<li>去掉额外的空格</li>
<li>用某种方法处理并转化为一系列的指令解析器处理</li>
<li><p>Run the tokens through the parser against the DOM</p>

<p> function Token (identity , finder ) {</p>

<pre><code> this.identity = identity ;
 this.finder = finder ;
</code></pre>

 }
 Token .prototype .toString = function () {

<pre><code> return 'identity: ' + this.identity + ', finder: ' + this.finder ;
</code></pre>

 };
 //The finder property is one of those keys in findMap. The identity is the original rule from the selector.

<h3>扫描器(Scanner)</h3>

<blockquote><p>CSS grammer specification
 macros = {</p>

<pre><code> 'nl': '\n|\r\n|\r|\f' ,
 'nonascii' : '[^\0-\177]' ,
 'unicode' : '\\[0-9A-Fa-f]{1,6}(\r\n|[\s\n\r\t\f])?'
 'escape' : '#{unicode}|\\[^\n\r\f0-9A-Fa-f]' ,
 'nmchar' : '[_A-Za-z0-9-]|#{nonascii}|#{escape}'
 'nmstart' : '[_A-Za-z]|#{nonascii}|#{escape}' ,
 'ident' : '[-@]?(#{nmstart})(#{nmchar})*' ,
 'name' : '(#{nmchar})+'
</code></pre>

<p> };
 rules = {</p>

<pre><code> 'id and name' : '(#{ident}##{ident})' ,
 'id': '(##{ident})' ,
 'class' : '(\\.#{ident})' ,
 'name and class' : '(#{ident}\\.#{ident})' ,
 'element' : '(#{ident})' ,
 'pseudo class' : '(:#{ident})'
</code></pre>

<p> };</p></blockquote></li>
</ol>


<h3>扫描器将做以下事情：</h3>

<ul>
<li>Expanding #{} in the macros</li>
<li>Expanding #{} in the rules based on the expanded macros</li>
<li>Escaping the backslashes</li>
<li>Joining each of the patterns with |</li>
<li>Building a global regular expression with the RegExp class</li>
</ul>


<h3>搜索器(Searcher)</h3>

<p>搜索器使用分词器的处理结果来搜索dom。初始化时需要指定搜索的root元素和一个token数组。</p>

<pre><code>find = {
byId: function (root, id) {
    return [root.getElementById (id)];
},
byNodeName : function (root, tagName ) {
    var i, results = [], nodes = root.getElementsByTagName (tagName );
    for (i = 0; i &lt; nodes .length ; i++) {
        results .push(nodes [i]);
    }
    return results ;
},
byClassName : function (root, className ) {
    var i, results = [], nodes = root.getElementsByTagName ('*');
    for (i = 0; i &lt; nodes .length ; i++) {
        if (nodes [i].className .match ('\\b' + className + '\\b' )) {
            results .push(nodes [i]);
        }
    }
    return results ;
}
};
findMap = {
'id': function (root, selector ) {
    selector = selector .split ('#')[1];
    return find.byId(root, selector );
},
'name and id' : function (root, selector ) {
    var matches = selector .split ('#'), name, id;
    name = matches [0];
    id = matches [1];
    return filter .byAttr (find.byId(root, id), 'nodeName' , name.toUpperCase ());
}
// ...
};
</code></pre>

<h2>Events</h2>

<h3>基本的事件绑定方式</h3>

<ol>
<li>inline</li>
<li>element.onXXX

<h3>访问事件</h3>

<p>event或者window.event，虽然直接访问window.event有潜在的危险，因为window.event是保存在上一次的事件对象，但javascript是单线程的，所以他是安全的。<br/>
中断事件(Stopping Events)</p></li>
<li>return false

<h3>事件捕获和冒泡</h3>

<p>why？</p></li>
<li>同时绑定给两个父子级元素绑定click事件，很难确定事件的执行顺序</li>
<li>不同的浏览器有不同的处理方法<br/>
How？<br/>
 function handler (event ) {

<pre><code> if (!event ) var event = window .event ;
 event .cancelBubble = true;
 if (event .stopPropagation ) event .stopPropagation ();
</code></pre>

 }

<h3>多个事件处理器</h3>

<p>eg：
 element .onclick = function () { alert ('Hello World!' ); return false ; };
 element .onclick = function () { alert ('This was the best example I could think of'); return false;}
 //这里第二个事件会将第一个事件覆盖</p></li>
</ol>


<h3>事件api的定义</h3>

<ol>
<li>Normalise event names, so onClick becomes click</li>
<li>Easy event registration and removal</li>
<li>Simple cross-browser access to the event object in handlers</li>
<li>Mask the complexities of event bubbling</li>
<li>Provide cross-browser access to keyboard and mouse interaction</li>
<li>Patch browser incompetency like IE memory leaks<br/>
jQuery的做法

<blockquote><p>$('a').click (function (event ) {<br/>
alert ('A link has been clicked' );<br/>
});<br/>
The Event’s element is in event.target<br/>
The current event within the bubbling phase is in event.currentTarget — also found in the
this object in the function  <br/>
The default action can be prevented with event.preventDefault()<br/>
Bubbling can be stopped with event.stopPropagation();<br/>
Events can be removed with $('a').unbind('click');<br/>
Events can be fired with $('a').trigger('click');</p></blockquote></li>
</ol>


<p>Prototype的做法</p>

<blockquote><p>$('id').observe ('click' , function (event ) {<br/>
var element = Event .element (event );<br/>
});<br/>
The Event’s element can be accessed with Event.element(event) or event.element();<br/>
Events are stopped with Event.stop()<br/>
Events can be removed with Event.stopObserving(element, eventName, handler);<br/>
Events can be fired with Event.fire(element)</p></blockquote>

<p>Glow的做法</p>

<blockquote><p>glow.events .addListener ('a', 'click' , function (event ) {  <br/>
alert ('Hello World!' );<br/>
});<br/>
The Event’s element is in event.source<br/>
The default action can be prevented by returning false<br/>
Events can be removed with glow.events.removeListener(handler) where handler is<br/>
the returned value from glow.events.addListener<br/>
Events can be fired with glow.events.fire()</p></blockquote>

<p>Dojo的做法</p>

<blockquote><p>dojo.connect (dojo.byId('a#hello' ), 'onclick' , function (event ) {</p>

<pre><code>alert ('Hello World!' );  
</code></pre>

<p>});<br/>
Notice that the event names aren’t mapped. Like the other frameworks, the event object is normalised.<br/>
The Event’s element is in event.target<br/>
The current event within the bubbling phase is in event.currentTarget — this is also this in
the function<br/>
The default action can be prevented with event.preventDefault()<br/>
Bubbling can be stopped with event.stopPropagation();<br/>
Events can be removed with dojo.disconnect()</p></blockquote>

<h3>总结</h3>

<p>在以上的framework中，jquery的event handler是最具有魅力的，首先，它统一使用W3C的事件系统在各个浏览器中，较好的名称空间，完全解决了事件冒泡问题，这主要是由于Micorosoft的API在冒泡时的问题。</p>

<h3>实现</h3>

<ol>
<li>event.srcElement , event.target</li>
<li>事件绑定  attachEvent,addEventlistener</li>
<li>验证元素是否有效，确保元素非文本和注释节点</li>
<li>阻止默认和冒泡事件</li>
<li>其他的浏览器修复</li>
<li>NodeList</li>
<li>事件代理<br/>
 //Safari’s handling of text nodes<br/>
 //Missing values for event.pageX/Y<br/>
 //Key events get event.which and event.metaKey is corrected<br/>
 //event.which is also added for mouse button index
 function stop(event ) {

<pre><code> event .preventDefault (event );
 event .stopPropagation (event );
</code></pre>

 }
 function fix(event , element ) {

<pre><code> if (!event ) var event = window .event ;
     event .stop = function () { stop(event ); };
 if (typeof event .target === 'undefined' )
     event .target = event .srcElement || element ;
 if (!event .preventDefault )
     event .preventDefault = function () { event .returnValue = false ; };
 if (!event .stopPropagation )
     event .stopPropagation = function () { event .cancelBubble = true; };
 return event ;
</code></pre>

 }
 var _isButton ;
 if (Prototype .Browser .IE) {

<pre><code> // IE doesn't map left/right/middle the same way.
 var buttonMap = { 0: 1, 1: 4, 2: 2 };
 _isButton = function (event , code) {
 return event .button === buttonMap [code];
</code></pre>

 } else if (Prototype .Browser .WebKit ) {

<pre><code> // In Safari we have to account for when the user holds down
 // the "meta" key.
 _isButton = function (event , code) {
 switch (code) {
     case 0: return event .which == 1 &amp;&amp; !event .metaKey ;
     case 1: return event .which == 1 &amp;&amp; event .metaKey ;
     default : return false ;
 }
</code></pre>

 } else {

<pre><code> _isButton = function (event , code) {
 return event .which ? (event .which === code + 1) : (event .button === code);
</code></pre>

<p> }</p></li>
</ol>


<h2>Ajax</h2>

<p><a href="http://www.w3.org/TR/XMLHttpRequest/">XMLHttpRequest</a></p>

<h3>how to cross domain ?</h3>

<ol>
<li>use flash or Silverlight</li>
<li>use XMLHttpRequest Level2 withCredentials attribute</li>
<li>using dynamically inserted script tags, image tags, and iframes.</li>
<li>JSONP</li>
<li>Cross-origin resource sharing ,eg: Access-Control-Allow-Origin: *</li>
<li>use XDomain object for IE</li>
</ol>


<h3>创建兼容的XMLHttpRequest对象</h3>

<ol>
<li>Differences between Microsoft’s implementation and W3C have to be dealt with</li>
<li>Request headers must be set for the type of data and HTTP methpd</li>
<li>State changes must be handled through callbacks</li>
<li><p>Browser bugs must be compensated for</p>

<p> function xhr() {
 if (typeof XMLHttpRequest !== 'undefined' &amp;&amp; (window .location .protocol !== 'file:' || !window.ActiveXObject)){
 return new XMLHttpRequest ();
 } else {
 try {
 return new ActiveXObject ('Msxml2.XMLHTTP.6.0' );
 } catch (e) { }
 try {
 return new ActiveXObject ('Msxml2.XMLHTTP.3.0' );
 } catch (e) { }
 try {
 return new ActiveXObject ('Msxml2.XMLHTTP' );
 } catch (e) { }
 }
 return false ;
 }</p></li>
</ol>


<h3>发送请求</h3>

<ol>
<li>Set a callback for onreadystatechange</li>
<li>Call open on the request object</li>
<li>Set the request headers</li>
<li>Call send on the object</li>
</ol>


<blockquote><p>readystate
0: Uninitialized: open has not been called
1: Loading: send has not been called
2: Loaded: send has been called, headers and status are available
3: Interactive: Downloading, responseText holds the partial data
4: Completed: Request finishe</p></blockquote>

<h3>ajax API设计</h3>

<p>jQuery</p>

<pre><code>$.ajax({
url: url,
data: data,
success : success ,
dataType : dataType
});
</code></pre>

<p>Prototype</p>

<pre><code>new Ajax.Request ('/your/url' , {
    onSuccess : function (response ) {
    // Handle the response content...
    }
});
</code></pre>

<p>Glow</p>

<pre><code>if (response .wasSuccessful ) {
    events .fire(request , "load" , response );
} else {
    events .fire(request , "error" , response );
}
</code></pre>

<h2>动画(Animations)</h2>

<h3>JavaScript动画</h3>

<p>Methods to work with CSS properties and animate them<br/>
A queuing system, for scheduling animations, and animating each “frame” CSS colour parsing<br/>
Helpers that make common web effects easy to use alongside events</p>

<h3>动画框架</h3>

<ol>
<li>最流行的框架<a href="http://madrobby.github.com/scriptaculous/combination-effects-demo/">aculo</a></li>
<li>Mootools <a href="http://mootools.net/docs/core/Fx/Fx">FX</a></li>
<li>jQuery <a href="http://api.jquery.com/animate/">animate</a></li>
<li>Glow <a href="http://www.bbc.co.uk/glow/docs/1.7/api/glow.anim.animation.shtml">animation</a>

<h3>动画队列</h3>

setInterval 和 clearInterval 来处理事件序列 <br/>
Easing function

<blockquote><p>“Ease-in” and “ease-out” in digital animation typically refer to a mechanism for defining the
‘physics’ of the transition between two animation states, eg. the linearity of a tween.</p></blockquote></li>
</ol>


<h3>编写 easing 函数</h3>

<pre><code>var easing = {};
easing .linear = function (position ) {
    return position ;
};
easing .sine = function (position ) {
    return (-Math.cos(position * Math.PI) / 2) + 0.5;
};
easing .sine = function (position ) {
    return (-Math.cos(position * Math.PI) / 2) + 0.5;
};
</code></pre>

<h3>动画helper函数 -- 一些比较常用的特效的封装</h3>

<ul>
<li>Fade — fade an element by changing its opacity</li>
<li>Highlight — rapidly change an element’s background colour to draw attention to it</li>
<li>Movement — move an element<br/>
  root.anim.fade(element , duration , { 'from' : '8em' , 'to': '100px' , 'easing' : easing });
  anim.fadeIn = function (element , duration , options ) {

<pre><code>                  options = options || {};
                  options .from = options .from || 0.0;
                  options .to = options .to || 1.0;
                  return anim.fade(element , duration , options );
              };
</code></pre>

  anim.fadeOut = function (element , duration , options ) {

<pre><code>                  var from;
                  options = options || {};
                  options .from = options .from || 1.0;
                  options .to = options .to || 0.0;
                  // Swap from and to
                  from = options .from;
                  options .from = options .to;
                  options .to = from;
                  // This easing function reverses the position value and adds from
                  options .easing = function (p) { return (1.0 - p) + options .from; };
                  return anim.fade(element , duration , options , { 'easing' : options .easing });
              };
</code></pre>

<h3>使用CSS3</h3>

<blockquote><p>CSS Transitions Module Level 3<br/>
CSS 2D Transforms Module Level 3<br/>
CSS 3D Transforms Module Level 3<br/>
CSS Animations Module Level 3</p></blockquote>

  .example {

<pre><code>  -webkit -transition : all 1s ease-in-out;
  -moz-transition : all 1s ease-in-out;
  -o-transition : all 1s ease-in-out;
  -webkit -transition : all 1s ease-in-out;
  transition : all 1s ease-in-out;
</code></pre>

<p>  }</p></li>
</ul>


<p>CSS3 动画<br/>
use keyframe</p>

<pre><code>@keyframes 'wobble' {
0% {
left: 100px;
}
40% {
left: 150px;
}
60% {
left: 75px;
}
100% {
left: 100px;
}
}
</code></pre>

<h3>动画性能</h3>

<ol>
<li>Animating margin, padding, background, outline, and border will all result in relatively
slow animations.</li>
<li>Hardware Acceleration

<h3>特性检测</h3>

是否支持硬件加速 <br/>
 function isHWAcceleratedSafari () {

<pre><code> var ua = navigator .userAgent , av = navigator .appVersion ;
 return (!ua.include ('Chrome' ) &amp;&amp; av.include ('10_6' )) ||
 Prototype .Browser .MobileSafari ;
</code></pre>

<p> }
是否支持WebKitTransitionEvent 或 MozTransition</p>

<p>  var div = document .createElement ('div' );
  try {</p>

<pre><code>  document .createEvent ("WebKitTransitionEvent" );
  supported = true;
  hardwareAccelerationSupported = isHWAcceleratedSafari ();
</code></pre>

  } catch (e) {
  if (typeof div.style .MozTransition !== 'undefined' ) {

<pre><code>  supported = true;
</code></pre>

  }
  }
  div = null;
查询浏览器厂商支持
  // CSS3 vendor detection
  vendors = {
  // Opera Presto 2.3
  'opera' : {

<pre><code>  'prefix' : '-o-' ,
  'detector' : function () {
      try {
          document .createEvent ('OTransitionEvent' );
          return true;
      } catch (e) {
          return false ;
      }
  }
</code></pre>

  },
  // Chrome 5, Safari 4
  'webkit' : {

<pre><code>  'prefix' : '-webkit-' ,
  'detector' : function () {
      try {
          document .createEvent ('WebKitTransitionEvent' );
          return true;
      } catch (e) {
          return false ;
      }
  }
</code></pre>

  },
  // Firefox 4
  'firefox' : {

<pre><code>  'prefix' : '-moz-' ,
  'detector' : function () {
      var div = document .createElement ('div' ),
      supported = false ;
      if (typeof div.style .MozTransition !== 'undefined' ) {
          supported = true;
      }
          div = null;
          return supported ;
      }
  }
</code></pre>

  };
  function findCSS3VendorPrefix () {

<pre><code>  for (var detector in vendors ) {
      detector = vendors [detector ];
      if (detector ['detector' ]()) {
          return detector ['prefix' ];
      }
  }
</code></pre>

  }

<h3>移动动画的实现</h3>

<p>Detect when a CSS property is being used to move an element<br/>
Get the vendor prefix<br/>
Set up CSS3 style properties instead of using JS animation engine</p></li>
</ol>


<h2>支持TouchScreen</h2>

<h3>目前支持的framework：</h3>

<ol>
<li><a href="http://www.jqtouch.com/">jQTouch</a> : iPhone, iPad and Android phones</li>
<li>Sencha Touch</li>
</ol>


<h3>Debugging Touch</h3>

<ol>
<li><a href="http://developer.android.com/guide/developing/tools/adb.html">Android Debug Bridge</a></li>
<li>Iphone debug console</li>
<li><a href="http://people.apache.org/~pmuellr/weinre/docs/latest/">Weinre</a></li>
</ol>


<h3>旋转  Orientation Property</h3>

<pre><code>root.touch.orientation = function () {
    var orientation = window .orientation ,
    orientationString = '';
    switch (orientation ) {
        case 0:
        orientationString += 'portrait' ;
        break ;
        case -90:
        orientationString += 'landscape right' ;
        break ;
        case 90:
        orientationString += 'landscape left' ;
        break ;
        case 180:
        orientationString += 'portrait upside-down'
        break ;
    }
    return [orientation , orientationString ];
};
</code></pre>

<p>Touch Events<br/>
touchstart<br/>
touchmove<br/>
touchend<br/>
touchcancel</p>

<h3>Touch 事件对象</h3>

<p>event.touches: All touches on the page<br/>
event.targetTouches: Touches for the target element<br/>
event.changedTouches: Changed touches for this event</p>

<h3>Touch state</h3>

<p>If there’s just one event and the position hasn’t changed, it’s a tap event<br/>
If touchmove fired, work out the distance of the movement and how long it took for a swipe</p>

<h2>链式调用API</h2>

<p><a href="http://code.google.com/p/fakequery/">fakeQuery</a></p>

<h3>总结</h3>

<p>A “container function” is used to create new objects without having to type new<br/>
It returns objects based on a CSS selector<br/>
A class is created and copied so usage of methods like find can be called in a chain</p>

<h3>Event Handler Shortcuts and Loop Scoping</h3>

<pre><code>events .addDOMethods = function () {
    if (typeof root .domChain === 'undefined' ) return ;
    root .domChain .bind = function (type, handler ) {
    var element = this.first ();
    if (element ) {
        root .events .add(element , type, handler );
        return this;
    }
};
var chainedAliases = ('click dblclick mouseover mouseout mousemove ' +
'mousedown mouseup blur focus change keydown ' +
'keypress keyup resize scroll' ).split (' ');
    for (var i = 0; i &lt; chainedAliases .length ; i++) {
        (function (name) {
        root .domChain [name] = function (handler ) {
        return this.bind(name, handler );
        };
        })(chainedAliases [i]);
    }
};
</code></pre>

<h2>特性检测  eg：querySelectorAll</h2>

<h3>实现</h3>

<pre><code>var testCache = {},
detectionTests = {};
root.addDetectionTest = function (name, fn) {
    if (!detectionTests [name])
    detectionTests [name] = fn;
    };
    root.detect = function (testName ) {
    if (typeof testCache [testCache ] === 'undefined' ) {
    testCache [testName ] = detectionTests [testName ]();
    }
    return testCache [testName ];
};
//检测querySelectorAll
turing .addDetectionTest ('querySelectorAll' , function () {
    var div = document .createElement ('div' );
    div.innerHTML = '&lt;p class="TEST"&gt;&lt;/p&gt;' ;
    // Some versions of Safari can't handle uppercase in quirks mode
    if (div.querySelectorAll ) {
        if (div.querySelectorAll ('.TEST' ).length === 0) return false ;
        return true;
    }
    // Helps IE release memory associated with the div
    div = null;
    return false ;
});
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS Web Applications]]></title>
    <link href="http://zjhiphop.github.com/blog/2012/06/03/js-web-applications/"/>
    <updated>2012-06-03T15:22:00+08:00</updated>
    <id>http://zjhiphop.github.com/blog/2012/06/03/js-web-applications</id>
    <content type="html"><![CDATA[<p>Anything that can go right will go right. --反墨菲定律</p>

<p>MVC and Classes</p>

<p>Events and Observing</p>

<p>Models and Data</p>

<p>Controllers and State</p>

<p>The Real-Time Web</p>

<p>Testing and Debugging</p>

<p>The Spine Library</p>

<p>The Backbone Library</p>

<p>The JavascriptMVC Library</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Byte-saving Technique]]></title>
    <link href="http://zjhiphop.github.com/blog/2012/06/02/js-saving-byte-tec/"/>
    <updated>2012-06-02T22:21:00+08:00</updated>
    <id>http://zjhiphop.github.com/blog/2012/06/02/js-saving-byte-tec</id>
    <content type="html"><![CDATA[<h3>Byte-saving Technique</h3>

<p>下面展示的是一系列javascript魔法，它可以剥掉一层你的JS代码！这些技术参考自"140bytes"，一下所说明的技术会帮助你减少JS的代码量，但是在性能方面还有很多方面有待考究！</p>

<h3>Arguments</h3>

<p>使用按字母排序的一个字母一个位置的参数<br/>
我们总是希望参数越短越好，这样可以在生命周期中尽可能的重用他们。最佳的处理方法是仅仅将他们用作一个占位符而不是总是尝试给予一个变量有意义的名字。同时使用一个字母命名法会稍微改变在单独函数中的可读性，保持一致的做法会对函数交互时的可读性有帮助！</p>

<pre><code>function(t,d,v,i,f){...} // before  
function(a,b,c,d,e){...} // after  
</code></pre>

<p>不要使用arguments.length去判断参数是否存在，使用in去检查是否有参数被传递</p>

<pre><code>arguments.length&gt;1||(cb=alert) // before  
1 in arguments||(cb=alert)     // after  
</code></pre>

<h3>Variables</h3>

<p>使用占位符取代var<br/>
通过在函数arguments声明取代var使用来节省字节</p>

<pre><code>function(a){var b=1;...} // before  
function(a,b){b=1;...}   // after  
</code></pre>

<p>尽可能的重用变量<br/>
谨慎使用那些不再使用的变量来节省字节</p>

<pre><code>setTimeout(function(){for(var i=10;i--;)... }, a) // before  
setTimeout(function(){for(a=10;a--;)... }, a)     // after  
</code></pre>

<p>无论何处，尽可能的赋值<br/>
因为分配变量会返回被赋得值，同时进行赋值和判断会节省一些字节。有一个很好的例子：JSONP函数，其中script是在createElement方法中被赋值的！</p>

<pre><code>a=this.localStorage;if(a){...} // before  
if(a=this.localStorage){...}   // after  
</code></pre>

<p>使用数组交换变量<br/>
数组可以用来临时保存数据占位，这样可以避免声明另一个变量！</p>

<pre><code>var a=1,b=2,c;c=a;a=b;b=c // before  
var a=1,b=2;a=[b,b=a][0]  // after  
</code></pre>

<p>强制原则使用开拓<br/>
JS强制原则是精华也是糟粕，但是有时相当有用。pubsub函数减少了负面的变量，然后使用一个字符串将结果连接起来，最终结果类似somestring-123，这个字符串会在后续处理中使用连字符“-”来还原为原始的字符串！（也许你可以看看）</p>

<h3>Loops</h3>

<p>忽略循环体<br/>
如果你能在循环条件中执行所有的逻辑，那么你就不需要循环体。示例：timeAgo使用for而不是while for和while需要相同的字节空间，但是for会给予你更多的赋值机会。</p>

<pre><code>while(i--){...} // before  
for(;i--;){...} // after  
i=10;while(i--){...} // before  
for(i=10;i--;){...}  // after  
</code></pre>

<p>使用存在的缩索引去迭代数组中的真实元素<br/>
当你迭代一组真实存在的数组对象时，缩短循环对象的回路将会减少很多字节。</p>

<pre><code>for(a=[1,2,3,4,5],l=a.length,i=0;i&lt;l;i++){b=a[i];...}  
for(a=[1,2,3,4,5],i=0;b=a[i++];){...}  
</code></pre>

<p>使用for..in来分配并且获得一个对象的keys</p>

<pre><code>a=[];for(b in window)a.push(window[b]) // before  
a=[];i=0;for(a[i++]in window);        // after  
</code></pre>

<h3>Operators</h3>

<p>理解操作符优先级<br/>
This Mozilla page是一个非常好的页面让你去开始学习。<br/>
理解位操作运算hacks<br/>
使用’~‘配合indexof来测试<br/>
Use ~ with indexOf to test presence</p>

<pre><code>hasAnF="This sentence has an f.".indexOf("f")&gt;=0 // before  
hasAnF=~"This sentence has an f.".indexOf("f")   // after  
~-1  
0  
~1  
-2  
~-2  
1  
~0  
-1  
</code></pre>

<p>使用’,’来在同一行串联表达式</p>

<pre><code>with(document){open();write("hello");close()}  
with(document)open(),write("hello"),close()  
</code></pre>

<p>使用’[].<em>’取代’void 0’，’undefined’("".</em> ，1.._和0[0]也会起作用，但是会更慢)
去除操作符之后的不必要的空格，操作符之后的空格不总是必须的，有时是可以忽略的！</p>

<pre><code>typeof [] // before  
typeof[]  // after  
</code></pre>

<h3>Numbers</h3>

<p>使用’<del>~’和’0|’取代Math.floor<br/>
以上这两种组合将会对数字取整(注意:</del>比|的优先级别低，除此之外没什么区别)</p>

<pre><code>rand10=Math.floor(Math.random()*10) // before  
rand10=0|Math.random()*10           // after  
</code></pre>

<p>使用AeB的格式书写大的十进制的数字<br/>
这种写法等价于A*Math.pow(10,B).</p>

<pre><code>million=1000000 // before  
million=1e6     // after  
</code></pre>

<p>使用A&lt;&lt;B的格式来书写一个大的二进制数据<br/>
这种写法等价于A*Math.pow(2,B). 示例：rgb2hex</p>

<pre><code>color=0x100000 // before  
color=1&lt;&lt;20    // after  
</code></pre>

<p>使用1/0来取代无穷(Infinity)<br/>
这种做法会更加简短。除此之外，division by zero gets you free internet points.</p>

<pre><code>[Infinity,-Infinity] // before  
[1/0,-1/0]           // after  
</code></pre>

<p>挖掘出0作为假(Exploit the "falsiness" of 0)<br/>
当比较几个数字时，通常将值转化为对0进行比较以达到是代码精简的目的！</p>

<pre><code>a==1||console.log("not one") // before  
!~-a||console.log("not one")  // after  
</code></pre>

<h3>Strings</h3>

<p>使用0来分隔字符串<br/>
使用0作为分隔符将会节省两个byte，示例：timeAgo</p>

<pre><code>"alpha,bravo,charlie".split(",") // before  
"alpha0bravo0charlie".split(0)   // after  
</code></pre>

<p>使用很少被知道的’.link’方法<br/>
Strings有一个内建的方法’link’,用来创建一个html link element。你可以查看示例： linkify 函数.</p>

<pre><code>html="&lt;a href=""+url+"" mce_href=""+url+""&gt;"+text+"&lt;/a&gt;" // before  
html=text.link(url)                   // after  
</code></pre>

<p>使用’replace’来创建强力的字符串迭代<br/>
因为 ‘replace’方法可以使用function作为第二个参数，它可以用来捕获大量的迭代’账簿’。你可以查看示例：templates and UUID functions.
使用数组来重复字符串</p>

<pre><code>for(a="",i=32;i--;)a+=0 // before  
a=Array(33).join(0)     // after  
</code></pre>

<h3>Conditionals</h3>

<p>尽可能的使用&amp;&amp;和||在所有的地方</p>

<pre><code>if(a)if(b)return c // before  
return a&amp;&amp;b&amp;&amp;c     // after  
if(!a)a=Infinity // before  
a||(a=Infinity)  // after  
</code></pre>

<h3>Arrays</h3>

<p>Use elision<br/>
Array elision 在某些特定的场景可以节省字节空间！查看示例： router API for a real-world example.</p>

<pre><code>[undefined,undefined,2] // before  
[,,2]                   // after  
// Note: Be mindful of elided elements at the end of the element list  
[2,undefined,undefined] // before length is 3  
[2,,]                   // after length is 2  
</code></pre>

<h3>Regular Expressions</h3>

<p>非规范化的缩减<br/>
//d{2}/比较灵活, //d/d/ 更加简短.<br/>
eval解析正则表达式比直接使用RegExp()更简短</p>

<pre><code>r=new RegExp("{"+p+"}","g") // before  
r=eval("/{"+p+"}/g")    // after  
</code></pre>

<h3>Booleans</h3>

<p>使用’!’来创建boolean<br/>
true 和 false 可以用’!’联合数字使用达到相同的效果</p>

<pre><code>[true,false] // before  
[!0,!1]      // after  
</code></pre>

<h3>Functions</h3>

<p>使用命名的函数进行递归<br/>
递归通常比循环更加简洁，因为递归会卸载掉栈调用的列表簿。查看示例：walk function.
使用命名的函数来保存状态
如果状态需要在函数调用的时候进行保存，那么使用命名的函数并且将他作容器使用。示例：JSONP function.</p>

<pre><code>function(i){return function(){console.log("called "+(++i)+" times")}}(0) // before  
(function a(){console.log("called "+(a.i=a.i+1||1)+" times")})           // after  
0,function a(){console.log("called "+(a.i=a.i+1||1)+" times")}           // another alternative  
</code></pre>

<p>忽略”()”当使用不带参数的new创建新的对象时<br/>
“new Object” 等价于 new Object()</p>

<pre><code>now = +new Date() // before  
now = +new Date   // after  
</code></pre>

<p>reutrn语句<br/>
当返回任何数据除了变量，不需要在return之后加空格return ：</p>

<pre><code>['foo',42,'bar']; // before  
return['foo',42,'bar'];  // after  
return {x:42,y:417}; // before  
return{x:42,y:417};  // after  
return .01; // before  
return.01;  // after  
</code></pre>

<p>正确的使用函数闭包 Use the right closure for the job<br/>
如果你需要立即执行函数，请使用最适当的闭包.</p>

<pre><code>;(function(){...})() // before  
new function(){...}  // after, if you plan on returning an object and can use `this`  
!function(){...}()   // after, if you don't need to return anything  
</code></pre>

<h3>In the browser</h3>

<p>使用浏览器对象避免额外的逻辑<br/>
你可以使用浏览器anchor elements去解析URLs取代自己写的逻辑。示例：parseURL, 将文本转化为html：escapeHTML.
Use global scope
因为window在浏览器中是一个全局对象，你可以直接引用它的任何属性。比如说document和location，除此之外还有其他比较有用的属性，像：innerWidth，查看示例： screensaver.</p>

<h3>APIs</h3>

<p>尽可能的对每个参数传递静态的数据<br/>
使用额外的字节去提供默认值<br/>
只做一件事并做到最好</p>

<h3>Other resources</h3>

<p>Ben Alman's explanation of his <a href="http://benalman.com/news/2010/08/organ1k-js1k-contest-entry/">JS1K entry</a>  <br/>
Marijn Haverbeke's explanation of his <a href="http://benalman.com/news/2010/08/organ1k-js1k-contest-entry/">JS1K entry</a><br/>
<a href="http://code.google.com/p/closure-compiler/issues/detail?id=36">Suggested Closure Compiler optimizations</a> <br/>
Angus Croll's <a href="http://javascriptweblog.wordpress.com/">blog</a></p>
]]></content>
  </entry>
  
</feed>
